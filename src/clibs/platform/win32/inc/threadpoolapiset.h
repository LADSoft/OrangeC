#ifndef _THREADPOOLAPISET_H
#define _THREADPOOLAPISET_H

#ifdef __ORANGEC__ 
#pragma GCC system_header
#endif

/* ApiSet api-ms-win-core-threadpool-l1 */

/* #include <apiset.h> */
#include <apisetcconv.h>
#include <minwindef.h>
#include <minwinbase.h>

typedef VOID (WINAPI *PTP_WIN32_IO_CALLBACK)(PTP_CALLBACK_INSTANCE, PVOID, PVOID, ULONG, ULONG_PTR, PTP_IO);

#if (_WIN32_WINNT >= 0x0600)

WINBASEAPI PTP_POOL WINAPI CreateThreadpool(PVOID);
WINBASEAPI VOID WINAPI SetThreadpoolThreadMaximum(PTP_POOL, DWORD);
WINBASEAPI BOOL WINAPI SetThreadpoolThreadMinimum(PTP_POOL, DWORD);
WINBASEAPI BOOL WINAPI SetThreadpoolStackInformation(PTP_POOL, PTP_POOL_STACK_INFORMATION);
WINBASEAPI BOOL WINAPI QueryThreadpoolStackInformation(PTP_POOL, PTP_POOL_STACK_INFORMATION);
WINBASEAPI VOID WINAPI CloseThreadpool(PTP_POOL);
WINBASEAPI PTP_CLEANUP_GROUP WINAPI CreateThreadpoolCleanupGroup(VOID);
WINBASEAPI VOID WINAPI CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP, BOOL, PVOID);
WINBASEAPI VOID WINAPI CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP);
WINBASEAPI VOID WINAPI SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE, HANDLE);
WINBASEAPI VOID WINAPI ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE, HANDLE, DWORD);
WINBASEAPI VOID WINAPI ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE, HANDLE);
WINBASEAPI VOID WINAPI LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE, PCRITICAL_SECTION);
WINBASEAPI VOID WINAPI FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE, HMODULE);
WINBASEAPI BOOL WINAPI CallbackMayRunLong(PTP_CALLBACK_INSTANCE);
WINBASEAPI VOID WINAPI DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE);
WINBASEAPI BOOL WINAPI TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK, PVOID, PTP_CALLBACK_ENVIRON);
WINBASEAPI PTP_WORK WINAPI CreateThreadpoolWork(PTP_WORK_CALLBACK, PVOID, PTP_CALLBACK_ENVIRON);
WINBASEAPI VOID WINAPI SubmitThreadpoolWork(PTP_WORK);
WINBASEAPI VOID WINAPI WaitForThreadpoolWorkCallbacks(PTP_WORK, BOOL);
WINBASEAPI VOID WINAPI CloseThreadpoolWork(PTP_WORK);
WINBASEAPI PTP_TIMER WINAPI CreateThreadpoolTimer(PTP_TIMER_CALLBACK, PVOID, PTP_CALLBACK_ENVIRON);
WINBASEAPI VOID WINAPI SetThreadpoolTimer(PTP_TIMER, PFILETIME, DWORD, DWORD);
WINBASEAPI BOOL WINAPI IsThreadpoolTimerSet(PTP_TIMER);
WINBASEAPI VOID WINAPI WaitForThreadpoolTimerCallbacks(PTP_TIMER, BOOL);
WINBASEAPI VOID WINAPI CloseThreadpoolTimer(PTP_TIMER);
WINBASEAPI PTP_WAIT WINAPI CreateThreadpoolWait(PTP_WAIT_CALLBACK, PVOID, PTP_CALLBACK_ENVIRON);
WINBASEAPI VOID WINAPI SetThreadpoolWait(PTP_WAIT, HANDLE, PFILETIME);
WINBASEAPI VOID WINAPI WaitForThreadpoolWaitCallbacks(PTP_WAIT, BOOL);
WINBASEAPI VOID WINAPI CloseThreadpoolWait(PTP_WAIT);
WINBASEAPI PTP_IO WINAPI CreateThreadpoolIo(HANDLE, PTP_WIN32_IO_CALLBACK, PVOID, PTP_CALLBACK_ENVIRON);
WINBASEAPI VOID WINAPI StartThreadpoolIo(PTP_IO);
WINBASEAPI VOID WINAPI CancelThreadpoolIo(PTP_IO);
WINBASEAPI VOID WINAPI WaitForThreadpoolIoCallbacks(PTP_IO, BOOL);
WINBASEAPI VOID WINAPI CloseThreadpoolIo(PTP_IO);
WINBASEAPI BOOL WINAPI SetThreadpoolTimerEx(PTP_TIMER, PFILETIME, DWORD, DWORD);
WINBASEAPI BOOL WINAPI SetThreadpoolWaitEx(PTP_WAIT, HANDLE, PFILETIME, PVOID);

#endif /* _WIN32_WINNT >= 0x0600 */

#endif /* _THREADPOOLAPISET_H */
