#ifdef DEFINE_GUID

DEFINE_GUID(GUID_DEVINTERFACE_DISK, 0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_CDROM, 0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_PARTITION, 0x53f5630aL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_TAPE, 0x53f5630bL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_WRITEONCEDISK, 0x53f5630cL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_VOLUME, 0x53f5630dL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_MEDIUMCHANGER, 0x53f56310L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_FLOPPY, 0x53f56311L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_CDCHANGER, 0x53f56312L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_STORAGEPORT, 0x2accfe60L, 0xc130, 0x11d2, 0xb0, 0x82, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_VMLUN, 0x6f416619L, 0x9f29, 0x42a5, 0xb2, 0x0b, 0x37, 0xe2, 0x19, 0xca, 0x02, 0xb0);
DEFINE_GUID(GUID_DEVINTERFACE_SES, 0x1790c9ecL, 0x47d5, 0x4df3, 0xb5, 0xaf, 0x9a, 0xdf, 0x3c, 0xf2, 0x3e, 0x48);

#define  WDI_STORAGE_PREDICT_FAILURE_DPS_GUID  {0xe9f2d03aL, 0x747c, 0x41c2, {0xbb, 0x9a, 0x02, 0xc6, 0x2b, 0x6d, 0x5f, 0xcb}};

DEFINE_GUID(GUID_DEVINTERFACE_HIDDEN_VOLUME, 0x7f108a28L, 0x9833, 0x4b3b, 0xb7, 0x80, 0x2c, 0x6b, 0x5f, 0xa5, 0xc0, 0x62);
DEFINE_GUID(GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB, 0x27447c21L, 0xbcc3, 0x4d07, 0xa0, 0x5b, 0xa3, 0x39, 0x5b, 0xb4, 0xee, 0xe7);
DEFINE_GUID(GUID_DEVINTERFACE_COMPORT, 0X86E0D1E0L, 0X8089, 0X11D0, 0X9C, 0XE4, 0X08, 0X00, 0X3E, 0X30, 0X1F, 0X73);
DEFINE_GUID(GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR, 0x4D36E978L, 0xE325, 0x11CE, 0xBF, 0xC1, 0x08, 0x00, 0x2B, 0xE1, 0x03, 0x18);

#define DiskClassGuid  GUID_DEVINTERFACE_DISK
#define CdRomClassGuid  GUID_DEVINTERFACE_CDROM
#define PartitionClassGuid  GUID_DEVINTERFACE_PARTITION
#define TapeClassGuid  GUID_DEVINTERFACE_TAPE
#define WriteOnceDiskClassGuid  GUID_DEVINTERFACE_WRITEONCEDISK
#define VolumeClassGuid  GUID_DEVINTERFACE_VOLUME
#define MediumChangerClassGuid  GUID_DEVINTERFACE_MEDIUMCHANGER
#define FloppyClassGuid  GUID_DEVINTERFACE_FLOPPY
#define CdChangerClassGuid  GUID_DEVINTERFACE_CDCHANGER
#define StoragePortClassGuid  GUID_DEVINTERFACE_STORAGEPORT

#define HiddenVolumeClassGuid  GUID_DEVINTERFACE_HIDDEN_VOLUME

#define GUID_CLASS_COMPORT  GUID_DEVINTERFACE_COMPORT
#define GUID_SERENUM_BUS_ENUMERATOR GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR

#endif /* DEFINE_GUID */


#ifdef DEFINE_DEVPROPKEY

DEFINE_DEVPROPKEY(DEVPKEY_Storage_Portable, 0x4d1ebee8, 0x803, 0x4774, 0x98, 0x42, 0xb7, 0x7d, 0xb5, 0x2, 0x65, 0xe9, 2);
DEFINE_DEVPROPKEY(DEVPKEY_Storage_Removable_Media, 0x4d1ebee8, 0x803, 0x4774, 0x98, 0x42, 0xb7, 0x7d, 0xb5, 0x2, 0x65, 0xe9, 3);
DEFINE_DEVPROPKEY(DEVPKEY_Storage_System_Critical, 0x4d1ebee8, 0x803, 0x4774, 0x98, 0x42, 0xb7, 0x7d, 0xb5, 0x2, 0x65, 0xe9, 4);

#endif /* DEFINE_DEVPROPKEY */


#ifndef _WINIOCTL_H
#define _WINIOCTL_H

#if __POCC__ >= 290
#pragma warn(push)
#pragma warn(disable:2185)  /* Alignment of field 'x' can be less than the natural alignment */
#pragma warn(disable:2197)  /* 'type' is not a standard bit-field type */
#pragma warn(disable:2198)  /* Nameless field is not standard */
#endif

#ifndef _DEVIOCTL_
#define _DEVIOCTL_

#define DEVICE_TYPE DWORD

#define FILE_DEVICE_BEEP  0x00000001
#define FILE_DEVICE_CD_ROM  0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER  0x00000004
#define FILE_DEVICE_DATALINK  0x00000005
#define FILE_DEVICE_DFS  0x00000006
#define FILE_DEVICE_DISK  0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM  0x00000008
#define FILE_DEVICE_FILE_SYSTEM  0x00000009
#define FILE_DEVICE_INPORT_PORT  0x0000000a
#define FILE_DEVICE_KEYBOARD  0x0000000b
#define FILE_DEVICE_MAILSLOT  0x0000000c
#define FILE_DEVICE_MIDI_IN  0x0000000d
#define FILE_DEVICE_MIDI_OUT  0x0000000e
#define FILE_DEVICE_MOUSE  0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE  0x00000011
#define FILE_DEVICE_NETWORK  0x00000012
#define FILE_DEVICE_NETWORK_BROWSER  0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL  0x00000015
#define FILE_DEVICE_PARALLEL_PORT  0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD  0x00000017
#define FILE_DEVICE_PRINTER  0x00000018
#define FILE_DEVICE_SCANNER  0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT  0x0000001a
#define FILE_DEVICE_SERIAL_PORT  0x0000001b
#define FILE_DEVICE_SCREEN  0x0000001c
#define FILE_DEVICE_SOUND  0x0000001d
#define FILE_DEVICE_STREAMS  0x0000001e
#define FILE_DEVICE_TAPE  0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM  0x00000020
#define FILE_DEVICE_TRANSPORT  0x00000021
#define FILE_DEVICE_UNKNOWN  0x00000022
#define FILE_DEVICE_VIDEO  0x00000023
#define FILE_DEVICE_VIRTUAL_DISK  0x00000024
#define FILE_DEVICE_WAVE_IN  0x00000025
#define FILE_DEVICE_WAVE_OUT  0x00000026
#define FILE_DEVICE_8042_PORT  0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY  0x00000029
#define FILE_DEVICE_BUS_EXTENDER  0x0000002a
#define FILE_DEVICE_MODEM  0x0000002b
#define FILE_DEVICE_VDM  0x0000002c
#define FILE_DEVICE_MASS_STORAGE  0x0000002d
#define FILE_DEVICE_SMB  0x0000002e
#define FILE_DEVICE_KS  0x0000002f
#define FILE_DEVICE_CHANGER  0x00000030
#define FILE_DEVICE_SMARTCARD  0x00000031
#define FILE_DEVICE_ACPI  0x00000032
#define FILE_DEVICE_DVD  0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO  0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM  0x00000035
#define FILE_DEVICE_DFS_VOLUME  0x00000036
#define FILE_DEVICE_SERENUM  0x00000037
#define FILE_DEVICE_TERMSRV  0x00000038
#define FILE_DEVICE_KSEC  0x00000039
#define FILE_DEVICE_FIPS  0x0000003A
#define FILE_DEVICE_INFINIBAND  0x0000003B
#define FILE_DEVICE_VMBUS  0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER  0x0000003F
#define FILE_DEVICE_WPD  0x00000040
#define FILE_DEVICE_BLUETOOTH  0x00000041
#define FILE_DEVICE_MT_COMPOSITE  0x00000042
#define FILE_DEVICE_MT_TRANSPORT  0x00000043
#define FILE_DEVICE_BIOMETRIC  0x00000044
#define FILE_DEVICE_PMI  0x00000045
#define FILE_DEVICE_EHSTOR  0x00000046
#define FILE_DEVICE_DEVAPI  0x00000047
#define FILE_DEVICE_GPIO  0x00000048
#define FILE_DEVICE_USBEX  0x00000049
#define FILE_DEVICE_CONSOLE  0x00000050
#define FILE_DEVICE_NFP  0x00000051
#define FILE_DEVICE_SYSENV  0x00000052
#define FILE_DEVICE_VIRTUAL_BLOCK  0x00000053
#define FILE_DEVICE_POINT_OF_SERVICE  0x00000054
#define FILE_DEVICE_STORAGE_REPLICATION 0x00000055
#define FILE_DEVICE_TRUST_ENV  0x00000056
#define FILE_DEVICE_UCM  0x00000057
#define FILE_DEVICE_UCMTCPCI  0x00000058


#define CTL_CODE(DeviceType, Function, Method, Access) (((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method))
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)  (((DWORD)(ctrlCode & 0xffff0000)) >> 16)
#define METHOD_FROM_CTL_CODE(ctrlCode)  ((DWORD)(ctrlCode & 3))

#define METHOD_BUFFERED  0
#define METHOD_IN_DIRECT  1
#define METHOD_OUT_DIRECT  2
#define METHOD_NEITHER  3

#define METHOD_DIRECT_TO_HARDWARE  METHOD_IN_DIRECT
#define METHOD_DIRECT_FROM_HARDWARE  METHOD_OUT_DIRECT

#define FILE_ANY_ACCESS  0
#define FILE_SPECIAL_ACCESS  (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS  (0x0001)
#define FILE_WRITE_ACCESS  (0x0002)

#endif /* _DEVIOCTL_ */


#ifndef _NTDDSTOR_H
#define _NTDDSTOR_H

#define IOCTL_STORAGE_BASE FILE_DEVICE_MASS_STORAGE

#define IOCTL_STORAGE_CHECK_VERIFY  CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_CHECK_VERIFY2  CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MEDIA_REMOVAL  CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_EJECT_MEDIA  CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA  CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA2  CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_RESERVE  CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RELEASE  CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_FIND_NEW_DEVICES  CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_EJECTION_CONTROL  CTL_CODE(IOCTL_STORAGE_BASE, 0x0250, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MCN_CONTROL  CTL_CODE(IOCTL_STORAGE_BASE, 0x0251, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_TYPES  CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_TYPES_EX  CTL_CODE(IOCTL_STORAGE_BASE, 0x0301, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER CTL_CODE(IOCTL_STORAGE_BASE, 0x0304, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_HOTPLUG_INFO  CTL_CODE(IOCTL_STORAGE_BASE, 0x0305, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_SET_HOTPLUG_INFO  CTL_CODE(IOCTL_STORAGE_BASE, 0x0306, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_RESET_BUS  CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RESET_DEVICE  CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_BREAK_RESERVATION  CTL_CODE(IOCTL_STORAGE_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_PERSISTENT_RESERVE_IN  CTL_CODE(IOCTL_STORAGE_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_PERSISTENT_RESERVE_OUT  CTL_CODE(IOCTL_STORAGE_BASE, 0x0407, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_GET_DEVICE_NUMBER  CTL_CODE(IOCTL_STORAGE_BASE, 0x0420, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_PREDICT_FAILURE  CTL_CODE(IOCTL_STORAGE_BASE, 0x0440, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_FAILURE_PREDICTION_CONFIG CTL_CODE(IOCTL_STORAGE_BASE, 0x0441, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_COUNTERS  CTL_CODE(IOCTL_STORAGE_BASE, 0x442, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_READ_CAPACITY  CTL_CODE(IOCTL_STORAGE_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_GET_DEVICE_TELEMETRY  CTL_CODE(IOCTL_STORAGE_BASE, 0x0470, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_DEVICE_TELEMETRY_NOTIFY  CTL_CODE(IOCTL_STORAGE_BASE, 0x0471, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_DEVICE_TELEMETRY_QUERY_CAPS CTL_CODE(IOCTL_STORAGE_BASE, 0x0472, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_GET_DEVICE_TELEMETRY_RAW  CTL_CODE(IOCTL_STORAGE_BASE, 0x0473, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_SET_TEMPERATURE_THRESHOLD  CTL_CODE(IOCTL_STORAGE_BASE, 0x0480, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_PROTOCOL_COMMAND  CTL_CODE(IOCTL_STORAGE_BASE, 0x04F0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_QUERY_PROPERTY  CTL_CODE(IOCTL_STORAGE_BASE, 0x0500, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES  CTL_CODE(IOCTL_STORAGE_BASE, 0x0501, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_GET_LB_PROVISIONING_MAP_RESOURCES  CTL_CODE(IOCTL_STORAGE_BASE, 0x0502, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_REINITIALIZE_MEDIA  CTL_CODE(IOCTL_STORAGE_BASE, 0x0590, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_GET_BC_PROPERTIES  CTL_CODE(IOCTL_STORAGE_BASE, 0x0600, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_ALLOCATE_BC_STREAM  CTL_CODE(IOCTL_STORAGE_BASE, 0x0601, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_FREE_BC_STREAM  CTL_CODE(IOCTL_STORAGE_BASE, 0x0602, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT  CTL_CODE(IOCTL_STORAGE_BASE, 0x0620, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_START_DATA_INTEGRITY_CHECK  CTL_CODE(IOCTL_STORAGE_BASE, 0x0621, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_STOP_DATA_INTEGRITY_CHECK  CTL_CODE(IOCTL_STORAGE_BASE, 0x0622, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define OBSOLETE_IOCTL_STORAGE_RESET_BUS  CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define OBSOLETE_IOCTL_STORAGE_RESET_DEVICE  CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_FIRMWARE_GET_INFO  CTL_CODE(IOCTL_STORAGE_BASE, 0x0700, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_FIRMWARE_DOWNLOAD  CTL_CODE(IOCTL_STORAGE_BASE, 0x0701, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_FIRMWARE_ACTIVATE  CTL_CODE(IOCTL_STORAGE_BASE, 0x0702, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_ENABLE_IDLE_POWER  CTL_CODE(IOCTL_STORAGE_BASE, 0x0720, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_IDLE_POWERUP_REASON  CTL_CODE(IOCTL_STORAGE_BASE, 0x0721, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_POWER_ACTIVE  CTL_CODE(IOCTL_STORAGE_BASE, 0x0722, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_POWER_IDLE  CTL_CODE(IOCTL_STORAGE_BASE, 0x0723, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_EVENT_NOTIFICATION CTL_CODE(IOCTL_STORAGE_BASE, 0x0724, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_DEVICE_POWER_CAP CTL_CODE(IOCTL_STORAGE_BASE, 0x0725, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_RPMB_COMMAND  CTL_CODE(IOCTL_STORAGE_BASE, 0x0726, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_ATTRIBUTE_MANAGEMENT CTL_CODE(IOCTL_STORAGE_BASE, 0x0727, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

typedef struct _STORAGE_HOTPLUG_INFO {
    DWORD Size;
    BOOLEAN MediaRemovable;
    BOOLEAN MediaHotplug;
    BOOLEAN DeviceHotplug;
    BOOLEAN WriteCacheEnableOverride;
} STORAGE_HOTPLUG_INFO, *PSTORAGE_HOTPLUG_INFO;

typedef struct _STORAGE_DEVICE_NUMBER {
    DEVICE_TYPE DeviceType;
    DWORD DeviceNumber;
    DWORD PartitionNumber;
} STORAGE_DEVICE_NUMBER, *PSTORAGE_DEVICE_NUMBER;

typedef struct _STORAGE_BUS_RESET_REQUEST {
    BYTE PathId;
} STORAGE_BUS_RESET_REQUEST, *PSTORAGE_BUS_RESET_REQUEST;

typedef struct STORAGE_BREAK_RESERVATION_REQUEST {
    DWORD Length;
    BYTE _unused;
    BYTE PathId;
    BYTE TargetId;
    BYTE Lun;
} STORAGE_BREAK_RESERVATION_REQUEST, *PSTORAGE_BREAK_RESERVATION_REQUEST;

typedef struct _PREVENT_MEDIA_REMOVAL {
    BOOLEAN PreventMediaRemoval;
} PREVENT_MEDIA_REMOVAL, *PPREVENT_MEDIA_REMOVAL;

typedef struct _CLASS_MEDIA_CHANGE_CONTEXT {
    DWORD MediaChangeCount;
    DWORD NewState;
} CLASS_MEDIA_CHANGE_CONTEXT, *PCLASS_MEDIA_CHANGE_CONTEXT;

typedef struct _TAPE_STATISTICS {
    DWORD Version;
    DWORD Flags;
    LARGE_INTEGER RecoveredWrites;
    LARGE_INTEGER UnrecoveredWrites;
    LARGE_INTEGER RecoveredReads;
    LARGE_INTEGER UnrecoveredReads;
    BYTE CompressionRatioReads;
    BYTE CompressionRatioWrites;
} TAPE_STATISTICS, *PTAPE_STATISTICS;

#define RECOVERED_WRITES_VALID  0x00000001
#define UNRECOVERED_WRITES_VALID 0x00000002
#define RECOVERED_READS_VALID  0x00000004
#define UNRECOVERED_READS_VALID  0x00000008
#define WRITE_COMPRESSION_INFO_VALID  0x00000010
#define READ_COMPRESSION_INFO_VALID  0x00000020

typedef struct _TAPE_GET_STATISTICS {
    DWORD Operation;
} TAPE_GET_STATISTICS, *PTAPE_GET_STATISTICS;

#define TAPE_RETURN_STATISTICS 0L
#define TAPE_RETURN_ENV_INFO  1L
#define TAPE_RESET_STATISTICS  2L

typedef enum _STORAGE_MEDIA_TYPE {
    DDS_4mm = 0x20,
    MiniQic,
    Travan,
    QIC,
    MP_8mm,
    AME_8mm,
    AIT1_8mm,
    DLT,
    NCTP,
    IBM_3480,
    IBM_3490E,
    IBM_Magstar_3590,
    IBM_Magstar_MP,
    STK_DATA_D3,
    SONY_DTF,
    DV_6mm,
    DMI,
    SONY_D2,
    CLEANER_CARTRIDGE,
    CD_ROM,
    CD_R,
    CD_RW,
    DVD_ROM,
    DVD_R,
    DVD_RW,
    MO_3_RW,
    MO_5_WO,
    MO_5_RW,
    MO_5_LIMDOW,
    PC_5_WO,
    PC_5_RW,
    PD_5_RW,
    ABL_5_WO,
    PINNACLE_APEX_5_RW,
    SONY_12_WO,
    PHILIPS_12_WO,
    HITACHI_12_WO,
    CYGNET_12_WO,
    KODAK_14_WO,
    MO_NFR_525,
    NIKON_12_RW,
    IOMEGA_ZIP,
    IOMEGA_JAZ,
    SYQUEST_EZ135,
    SYQUEST_EZFLYER,
    SYQUEST_SYJET,
    AVATAR_F2,
    MP2_8mm,
    DST_S,
    DST_M,
    DST_L,
    VXATape_1,
    VXATape_2,
    STK_9840,
    LTO_Ultrium,
    LTO_Accelis,
    DVD_RAM,
    AIT_8mm,
    ADR_1,
    ADR_2,
    STK_9940,
    SAIT,
    VXATape
} STORAGE_MEDIA_TYPE, *PSTORAGE_MEDIA_TYPE;

#define MEDIA_ERASEABLE  0x00000001
#define MEDIA_WRITE_ONCE  0x00000002
#define MEDIA_READ_ONLY  0x00000004
#define MEDIA_READ_WRITE  0x00000008

#define MEDIA_WRITE_PROTECTED  0x00000100
#define MEDIA_CURRENTLY_MOUNTED 0x80000000

typedef enum _STORAGE_BUS_TYPE {
    BusTypeUnknown = 0x00,
    BusTypeScsi,
    BusTypeAtapi,
    BusTypeAta,
    BusType1394,
    BusTypeSsa,
    BusTypeFibre,
    BusTypeUsb,
    BusTypeRAID,
    BusTypeiScsi,
    BusTypeSas,
    BusTypeSata,
    BusTypeSd,
    BusTypeMmc,
    BusTypeVirtual,
    BusTypeFileBackedVirtual,
    BusTypeSpaces,
    BusTypeNvme,
    BusTypeSCM,
    BusTypeMax,
    BusTypeMaxReserved = 0x7F
} STORAGE_BUS_TYPE, *PSTORAGE_BUS_TYPE;

#define SupportsDeviceSharing( BusType ) ( \
  (BusType == BusTypeScsi)  ||  \
  (BusType == BusTypeFibre) ||  \
  (BusType == BusTypeiScsi) ||  \
  (BusType == BusTypeSas)  ||  \
  (BusType == BusTypeSpaces) )

typedef struct _DEVICE_MEDIA_INFO {
    union {
        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            DWORD TracksPerCylinder;
            DWORD SectorsPerTrack;
            DWORD BytesPerSector;
            DWORD NumberMediaSides;
            DWORD MediaCharacteristics;
        } DiskInfo;
        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            DWORD TracksPerCylinder;
            DWORD SectorsPerTrack;
            DWORD BytesPerSector;
            DWORD NumberMediaSides;
            DWORD MediaCharacteristics;
        } RemovableDiskInfo;
        struct {
            STORAGE_MEDIA_TYPE MediaType;
            DWORD MediaCharacteristics;
            DWORD CurrentBlockSize;
            STORAGE_BUS_TYPE BusType;
            union {
                struct {
                    BYTE MediumType;
                    BYTE DensityCode;
                } ScsiInformation;
            } BusSpecificData;
        } TapeInfo;
    } DeviceSpecific;
} DEVICE_MEDIA_INFO, *PDEVICE_MEDIA_INFO;

typedef struct _GET_MEDIA_TYPES {
    DWORD DeviceType;
    DWORD MediaInfoCount;
    DEVICE_MEDIA_INFO MediaInfo[1];
} GET_MEDIA_TYPES, *PGET_MEDIA_TYPES;

typedef struct _STORAGE_PREDICT_FAILURE {
    DWORD PredictFailure;
    BYTE VendorSpecific[512];
} STORAGE_PREDICT_FAILURE, *PSTORAGE_PREDICT_FAILURE;

typedef struct _STORAGE_FAILURE_PREDICTION_CONFIG {
    DWORD Version;
    DWORD Size;
    BOOLEAN Set;
    BOOLEAN Enabled;
    WORD Reserved;
} STORAGE_FAILURE_PREDICTION_CONFIG, *PSTORAGE_FAILURE_PREDICTION_CONFIG;

#define STORAGE_FAILURE_PREDICTION_CONFIG_V1 1

typedef enum _STORAGE_QUERY_TYPE {
    PropertyStandardQuery = 0,
    PropertyExistsQuery,
    PropertyMaskQuery,
    PropertyQueryMaxDefined
} STORAGE_QUERY_TYPE, *PSTORAGE_QUERY_TYPE;

typedef enum _STORAGE_PROPERTY_ID {
    StorageDeviceProperty = 0,
    StorageAdapterProperty,
    StorageDeviceIdProperty,
    StorageDeviceUniqueIdProperty,
    StorageDeviceWriteCacheProperty,
    StorageMiniportProperty,
    StorageAccessAlignmentProperty,
    StorageDeviceSeekPenaltyProperty,
    StorageDeviceTrimProperty,
    StorageDeviceWriteAggregationProperty,
    StorageDeviceDeviceTelemetryProperty,
    StorageDeviceLBProvisioningProperty,
    StorageDevicePowerProperty,
    StorageDeviceCopyOffloadProperty,
    StorageDeviceResiliencyProperty,
    StorageDeviceMediumProductType,
    StorageAdapterRpmbProperty,
    StorageDeviceIoCapabilityProperty = 48,
    StorageAdapterProtocolSpecificProperty,
    StorageDeviceProtocolSpecificProperty,
    StorageAdapterTemperatureProperty,
    StorageDeviceTemperatureProperty,
    StorageAdapterPhysicalTopologyProperty,
    StorageDevicePhysicalTopologyProperty,
    StorageDeviceAttributesProperty,
    StorageDeviceManagementStatus,
    StorageAdapterSerialNumberProperty,
    StorageDeviceLocationProperty,
} STORAGE_PROPERTY_ID, *PSTORAGE_PROPERTY_ID;

typedef struct _STORAGE_PROPERTY_QUERY {
    STORAGE_PROPERTY_ID PropertyId;
    STORAGE_QUERY_TYPE QueryType;
    BYTE AdditionalParameters[1];
} STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;

typedef struct _STORAGE_DESCRIPTOR_HEADER {
    DWORD Version;
    DWORD Size;
} STORAGE_DESCRIPTOR_HEADER, *PSTORAGE_DESCRIPTOR_HEADER;

typedef struct _STORAGE_DEVICE_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    BYTE DeviceType;
    BYTE DeviceTypeModifier;
    BOOLEAN RemovableMedia;
    BOOLEAN CommandQueueing;
    DWORD VendorIdOffset;
    DWORD ProductIdOffset;
    DWORD ProductRevisionOffset;
    DWORD SerialNumberOffset;
    STORAGE_BUS_TYPE BusType;
    DWORD RawPropertiesLength;
    BYTE RawDeviceProperties[1];
} STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;

typedef struct _STORAGE_ADAPTER_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD MaximumTransferLength;
    DWORD MaximumPhysicalPages;
    DWORD AlignmentMask;
    BOOLEAN AdapterUsesPio;
    BOOLEAN AdapterScansDown;
    BOOLEAN CommandQueueing;
    BOOLEAN AcceleratedTransfer;
    BYTE BusType;
    WORD BusMajorVersion;
    WORD BusMinorVersion;
#if (NTDDI_VERSION >= NTDDI_WIN8)
    BYTE SrbType;
    BYTE AddressType;
#endif /* NTDDI_VERSION >= NTDDI_WIN8 */
} STORAGE_ADAPTER_DESCRIPTOR, *PSTORAGE_ADAPTER_DESCRIPTOR;

#if (NTDDI_VERSION >= NTDDI_WIN8)
#define NO_SRBTYPE_ADAPTER_DESCRIPTOR_SIZE  FIELD_OFFSET(STORAGE_ADAPTER_DESCRIPTOR, SrbType)
#if !defined(SRB_TYPE_SCSI_REQUEST_BLOCK)
#define SRB_TYPE_SCSI_REQUEST_BLOCK  0
#endif
#if !defined(SRB_TYPE_STORAGE_REQUEST_BLOCK)
#define SRB_TYPE_STORAGE_REQUEST_BLOCK  1
#endif
#if !defined(STORAGE_ADDRESS_TYPE_BTL8)
#define STORAGE_ADDRESS_TYPE_BTL8  0
#endif
#endif /* NTDDI_VERSION >= NTDDI_WIN8 */

typedef struct _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR {

    DWORD Version;
    DWORD Size;
    DWORD BytesPerCacheLine;
    DWORD BytesOffsetForCacheAlignment;
    DWORD BytesPerLogicalSector;
    DWORD BytesPerPhysicalSector;
    DWORD BytesOffsetForSectorAlignment;

} STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR, *PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;

typedef struct _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD MediumProductType;
} STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR, *PSTORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;

typedef enum _STORAGE_PORT_CODE_SET {
    StoragePortCodeSetReserved = 0,
    StoragePortCodeSetStorport = 1,
    StoragePortCodeSetSCSIport = 2,
    StoragePortCodeSetSpaceport = 3,
    StoragePortCodeSetATAport = 4,
    StoragePortCodeSetUSBport = 5,
    StoragePortCodeSetSBP2port = 6,
    StoragePortCodeSetSDport = 7
} STORAGE_PORT_CODE_SET, *PSTORAGE_PORT_CODE_SET;

#if (NTDDI_VERSION >= NTDDI_WIN8)
#define STORAGE_MINIPORT_DESCRIPTOR_V1_SIZE  RTL_SIZEOF_THROUGH_FIELD(STORAGE_MINIPORT_DESCRIPTOR, IoTimeoutValue)
#endif /* NTDDI_VERSION >= NTDDI_WIN8 */

typedef struct _STORAGE_MINIPORT_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    STORAGE_PORT_CODE_SET Portdriver;
    BOOLEAN LUNResetSupported;
    BOOLEAN TargetResetSupported;
#if (NTDDI_VERSION >= NTDDI_WIN8)
    WORD IoTimeoutValue;
#endif
#if (NTDDI_VERSION >= NTDDI_WINBLUE)
    BOOLEAN ExtraIoInfoSupported;
    BYTE Reserved0[3];
    DWORD Reserved1;
#endif
} STORAGE_MINIPORT_DESCRIPTOR, *PSTORAGE_MINIPORT_DESCRIPTOR;

typedef enum _STORAGE_IDENTIFIER_CODE_SET {
    StorageIdCodeSetReserved = 0,
    StorageIdCodeSetBinary = 1,
    StorageIdCodeSetAscii = 2,
    StorageIdCodeSetUtf8 = 3
} STORAGE_IDENTIFIER_CODE_SET, *PSTORAGE_IDENTIFIER_CODE_SET;

typedef enum _STORAGE_IDENTIFIER_TYPE {
    StorageIdTypeVendorSpecific = 0,
    StorageIdTypeVendorId = 1,
    StorageIdTypeEUI64 = 2,
    StorageIdTypeFCPHName = 3,
    StorageIdTypePortRelative = 4,
    StorageIdTypeTargetPortGroup = 5,
    StorageIdTypeLogicalUnitGroup = 6,
    StorageIdTypeMD5LogicalUnitIdentifier = 7,
    StorageIdTypeScsiNameString = 8
} STORAGE_IDENTIFIER_TYPE, *PSTORAGE_IDENTIFIER_TYPE;

#define StorageIdTypeNAA  StorageIdTypeFCPHName

typedef enum _STORAGE_ID_NAA_FORMAT {
    StorageIdNAAFormatIEEEExtended = 2,
    StorageIdNAAFormatIEEERegistered = 3,
    StorageIdNAAFormatIEEEERegisteredExtended = 5
} STORAGE_ID_NAA_FORMAT, *PSTORAGE_ID_NAA_FORMAT;

typedef enum _STORAGE_ASSOCIATION_TYPE {
    StorageIdAssocDevice = 0,
    StorageIdAssocPort = 1,
    StorageIdAssocTarget = 2
} STORAGE_ASSOCIATION_TYPE, *PSTORAGE_ASSOCIATION_TYPE;

typedef struct _STORAGE_IDENTIFIER {
    STORAGE_IDENTIFIER_CODE_SET CodeSet;
    STORAGE_IDENTIFIER_TYPE Type;
    WORD IdentifierSize;
    WORD NextOffset;
    STORAGE_ASSOCIATION_TYPE Association;
    BYTE Identifier[1];
} STORAGE_IDENTIFIER, *PSTORAGE_IDENTIFIER;

typedef struct _STORAGE_DEVICE_ID_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD NumberOfIdentifiers;
    BYTE Identifiers[1];
} STORAGE_DEVICE_ID_DESCRIPTOR, *PSTORAGE_DEVICE_ID_DESCRIPTOR;

typedef struct _DEVICE_SEEK_PENALTY_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    BOOLEAN IncursSeekPenalty;
} DEVICE_SEEK_PENALTY_DESCRIPTOR, *PDEVICE_SEEK_PENALTY_DESCRIPTOR;

typedef struct _DEVICE_WRITE_AGGREGATION_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    BOOLEAN BenefitsFromWriteAggregation;
} DEVICE_WRITE_AGGREGATION_DESCRIPTOR, *PDEVICE_WRITE_AGGREGATION_DESCRIPTOR;

typedef struct _DEVICE_TRIM_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    BOOLEAN TrimEnabled;
} DEVICE_TRIM_DESCRIPTOR, *PDEVICE_TRIM_DESCRIPTOR;

typedef struct _DEVICE_LB_PROVISIONING_DESCRIPTOR {
    DWORD Version;
    DWORD Size;

    BYTE ThinProvisioningEnabled:1;
    BYTE ThinProvisioningReadZeros:1;
    BYTE AnchorSupported:3;
    BYTE UnmapGranularityAlignmentValid:1;
    BYTE Reserved0:2;
    BYTE Reserved1[7];
    DWORDLONG OptimalUnmapGranularity;
    DWORDLONG UnmapGranularityAlignment;
#if (NTDDI_VERSION >= NTDDI_WINBLUE)
    DWORD MaxUnmapLbaCount;
    DWORD MaxUnmapBlockDescriptorCount;
#endif /* NTDDI_VERSION >= NTDDI_WINBLUE */
} DEVICE_LB_PROVISIONING_DESCRIPTOR, *PDEVICE_LB_PROVISIONING_DESCRIPTOR;

#define DEVICE_LB_PROVISIONING_DESCRIPTOR_V1_SIZE  RTL_SIZEOF_THROUGH_FIELD(DEVICE_LB_PROVISIONING_DESCRIPTOR, UnmapGranularityAlignment)

typedef struct _STORAGE_LB_PROVISIONING_MAP_RESOURCES {
    DWORD Size;
    DWORD Version;
    BYTE AvailableMappingResourcesValid:1;
    BYTE UsedMappingResourcesValid:1;
    BYTE Reserved0:6;
    BYTE Reserved1[3];
    BYTE AvailableMappingResourcesScope:2;
    BYTE UsedMappingResourcesScope:2;
    BYTE Reserved2:4;
    BYTE Reserved3[3];
    DWORDLONG AvailableMappingResources;
    DWORDLONG UsedMappingResources;
} STORAGE_LB_PROVISIONING_MAP_RESOURCES, *PSTORAGE_LB_PROVISIONING_MAP_RESOURCES;

typedef struct _DEVICE_POWER_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    BOOLEAN DeviceAttentionSupported;
    BOOLEAN AsynchronousNotificationSupported;
    BOOLEAN IdlePowerManagementEnabled;
    BOOLEAN D3ColdEnabled;
    BOOLEAN D3ColdSupported;
    BOOLEAN NoVerifyDuringIdlePower;
    BYTE Reserved[2];
    DWORD IdleTimeoutInMS;
} DEVICE_POWER_DESCRIPTOR, *PDEVICE_POWER_DESCRIPTOR;

typedef struct _DEVICE_COPY_OFFLOAD_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD MaximumTokenLifetime;
    DWORD DefaultTokenLifetime;
    DWORDLONG MaximumTransferSize;
    DWORDLONG OptimalTransferCount;
    DWORD MaximumDataDescriptors;
    DWORD MaximumTransferLengthPerDescriptor;
    DWORD OptimalTransferLengthPerDescriptor;
    WORD OptimalTransferLengthGranularity;
    BYTE Reserved[2];
} DEVICE_COPY_OFFLOAD_DESCRIPTOR, *PDEVICE_COPY_OFFLOAD_DESCRIPTOR;

typedef struct _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD NameOffset;
    DWORD NumberOfLogicalCopies;
    DWORD NumberOfPhysicalCopies;
    DWORD PhysicalDiskRedundancy;
    DWORD NumberOfColumns;
    DWORD Interleave;
} STORAGE_DEVICE_RESILIENCY_DESCRIPTOR, *PSTORAGE_DEVICE_RESILIENCY_DESCRIPTOR;

typedef enum _STORAGE_RPMB_FRAME_TYPE {
    StorageRpmbFrameTypeUnknown = 0,
    StorageRpmbFrameTypeStandard,
    StorageRpmbFrameTypeMax,
} STORAGE_RPMB_FRAME_TYPE, *PSTORAGE_RPMB_FRAME_TYPE;

#define STORAGE_RPMB_DESCRIPTOR_VERSION_1  1

#define STORAGE_RPMB_MINIMUM_RELIABLE_WRITE_SIZE  512

typedef struct _STORAGE_RPMB_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD SizeInBytes;
    DWORD MaxReliableWriteSizeInBytes;
    STORAGE_RPMB_FRAME_TYPE FrameFormat;
} STORAGE_RPMB_DESCRIPTOR, *PSTORAGE_RPMB_DESCRIPTOR;

#define STORAGE_TIER_NAME_LENGTH  (256)
#define STORAGE_TIER_DESCRIPTION_LENGTH  (512)

#define STORAGE_TIER_FLAG_NO_SEEK_PENALTY  (0x00020000)
#define STORAGE_TIER_FLAG_WRITE_BACK_CACHE (0x00200000)
#define STORAGE_TIER_FLAG_READ_CACHE  (0x00400000)
#define STORAGE_TIER_FLAG_PARITY  (0x00800000)

typedef enum _STORAGE_TIER_MEDIA_TYPE {
    StorageTierMediaTypeUnspecified = 0,
    StorageTierMediaTypeDisk,
    StorageTierMediaTypeSsd
} STORAGE_TIER_MEDIA_TYPE, *PSTORAGE_TIER_MEDIA_TYPE;

typedef struct _STORAGE_TIER {
    GUID Id;
    WCHAR Name[STORAGE_TIER_NAME_LENGTH];
    WCHAR Description[STORAGE_TIER_NAME_LENGTH];
    DWORDLONG Flags;
    DWORDLONG ProvisionedCapacity;
    STORAGE_TIER_MEDIA_TYPE MediaType;
} STORAGE_TIER, *PSTORAGE_TIER;

typedef struct _STORAGE_DEVICE_TIERING_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    DWORD TotalNumberOfTiers;
    DWORD NumberOfTiersReturned;
    STORAGE_TIER Tiers[ANYSIZE_ARRAY];
} STORAGE_DEVICE_TIERING_DESCRIPTOR, *PSTORAGE_DEVICE_TIERING_DESCRIPTOR;

typedef struct _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD NumberOfFaultDomains;
    GUID FaultDomainIds[ANYSIZE_ARRAY];
} STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR, *PSTORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;

typedef enum _STORAGE_PROTOCOL_TYPE {
    ProtocolTypeUnknown = 0x00,
    ProtocolTypeScsi,
    ProtocolTypeAta,
    ProtocolTypeNvme,
    ProtocolTypeSd,
    ProtocolTypeProprietary = 0x7E,
    ProtocolTypeMaxReserved = 0x7F
} STORAGE_PROTOCOL_TYPE, *PSTORAGE_PROTOCOL_TYPE;

typedef enum _STORAGE_PROTOCOL_NVME_DATA_TYPE {
    NVMeDataTypeUnknown = 0,
    NVMeDataTypeIdentify,
    NVMeDataTypeLogPage,
    NVMeDataTypeFeature,
} STORAGE_PROTOCOL_NVME_DATA_TYPE, *PSTORAGE_PROTOCOL_NVME_DATA_TYPE;

typedef enum _STORAGE_PROTOCOL_ATA_DATA_TYPE {
    AtaDataTypeUnknown = 0,
    AtaDataTypeIdentify,
    AtaDataTypeLogPage,
} STORAGE_PROTOCOL_ATA_DATA_TYPE, *PSTORAGE_PROTOCOL_ATA_DATA_TYPE;

typedef struct _STORAGE_PROTOCOL_SPECIFIC_DATA {
    STORAGE_PROTOCOL_TYPE ProtocolType;
    DWORD DataType;
    DWORD ProtocolDataRequestValue;
    DWORD ProtocolDataRequestSubValue;
    DWORD ProtocolDataOffset;
    DWORD ProtocolDataLength;
    DWORD FixedProtocolReturnData;
    DWORD Reserved[3];
} STORAGE_PROTOCOL_SPECIFIC_DATA, *PSTORAGE_PROTOCOL_SPECIFIC_DATA;

typedef struct _STORAGE_PROTOCOL_DATA_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    STORAGE_PROTOCOL_SPECIFIC_DATA ProtocolSpecificData;
} STORAGE_PROTOCOL_DATA_DESCRIPTOR, *PSTORAGE_PROTOCOL_DATA_DESCRIPTOR;

#define STORAGE_TEMPERATURE_VALUE_NOT_REPORTED  0x8000

typedef struct _STORAGE_TEMPERATURE_INFO {
    WORD Index;
    SHORT Temperature;
    SHORT OverThreshold;
    SHORT UnderThreshold;
    BOOLEAN OverThresholdChangable;
    BOOLEAN UnderThresholdChangable;
    BOOLEAN EventGenerated;
    BYTE Reserved0;
    DWORD Reserved1;
} STORAGE_TEMPERATURE_INFO, *PSTORAGE_TEMPERATURE_INFO;

typedef struct _STORAGE_TEMPERATURE_DATA_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    SHORT CriticalTemperature;
    SHORT WarningTemperature;
    WORD InfoCount;
    BYTE Reserved0[2];
    DWORD Reserved1[2];
    STORAGE_TEMPERATURE_INFO TemperatureInfo[ANYSIZE_ARRAY];
} STORAGE_TEMPERATURE_DATA_DESCRIPTOR, *PSTORAGE_TEMPERATURE_DATA_DESCRIPTOR;

#define STORAGE_TEMPERATURE_THRESHOLD_FLAG_ADAPTER_REQUEST  0x0001

typedef struct _STORAGE_TEMPERATURE_THRESHOLD {
    DWORD Version;
    DWORD Size;
    WORD Flags;
    WORD Index;
    SHORT Threshold;
    BOOLEAN OverThreshold;
    BYTE Reserved;
} STORAGE_TEMPERATURE_THRESHOLD, *PSTORAGE_TEMPERATURE_THRESHOLD;

#define STORAGE_COMPONENT_ROLE_CACHE  0x00000001
#define STORAGE_COMPONENT_ROLE_TIERING  0x00000002
#define STORAGE_COMPONENT_ROLE_DATA  0x00000004

typedef enum _STORAGE_DEVICE_FORM_FACTOR {
    FormFactorUnknown = 0,
    FormFactor3_5,
    FormFactor2_5,
    FormFactor1_8,
    FormFactor1_8Less,
    FormFactorEmbedded,
    FormFactorMemoryCard,
    FormFactormSata,
    FormFactorM_2,
    FormFactorPCIeBoard,
    FormFactorDimm,
} STORAGE_DEVICE_FORM_FACTOR, *PSTORAGE_DEVICE_FORM_FACTOR;

typedef enum _STORAGE_COMPONENT_HEALTH_STATUS {
    HealthStatusUnknown = 0,
    HealthStatusNormal,
    HealthStatusThrottled,
    HealthStatusWarning,
    HealthStatusDisabled,
    HealthStatusFailed,
} STORAGE_COMPONENT_HEALTH_STATUS, *PSTORAGE_COMPONENT_HEALTH_STATUS;

typedef union _STORAGE_SPEC_VERSION {
    struct {
        union {
            struct {
                BYTE SubMinor;
                BYTE Minor;
            } DUMMYSTRUCTNAME;
            WORD AsUshort;
        } MinorVersion;
        WORD MajorVersion;
    } DUMMYSTRUCTNAME;
    DWORD AsUlong;
} STORAGE_SPEC_VERSION, *PSTORAGE_SPEC_VERSION;

typedef struct _STORAGE_PHYSICAL_DEVICE_DATA {
    DWORD DeviceId;
    DWORD Role;
    STORAGE_COMPONENT_HEALTH_STATUS HealthStatus;
    STORAGE_PROTOCOL_TYPE CommandProtocol;
    STORAGE_SPEC_VERSION SpecVersion;
    STORAGE_DEVICE_FORM_FACTOR FormFactor;
    BYTE Vendor[8];
    BYTE Model[40];
    BYTE FirmwareRevision[16];
    DWORDLONG Capacity;
    BYTE PhysicalLocation[32];
    DWORD Reserved[2];
} STORAGE_PHYSICAL_DEVICE_DATA, *PSTORAGE_PHYSICAL_DEVICE_DATA;

typedef struct _STORAGE_PHYSICAL_ADAPTER_DATA {
    DWORD AdapterId;
    STORAGE_COMPONENT_HEALTH_STATUS HealthStatus;
    STORAGE_PROTOCOL_TYPE CommandProtocol;
    STORAGE_SPEC_VERSION SpecVersion;
    BYTE Vendor[8];
    BYTE Model[40];
    BYTE FirmwareRevision[16];
    BYTE PhysicalLocation[32];
    BOOLEAN ExpanderConnected;
    BYTE Reserved0[3];
    DWORD Reserved1[3];
} STORAGE_PHYSICAL_ADAPTER_DATA, *PSTORAGE_PHYSICAL_ADAPTER_DATA;

typedef struct _STORAGE_PHYSICAL_NODE_DATA {
    DWORD NodeId;
    DWORD AdapterCount;
    DWORD AdapterDataLength;
    DWORD AdapterDataOffset;
    DWORD DeviceCount;
    DWORD DeviceDataLength;
    DWORD DeviceDataOffset;
    DWORD Reserved[3];
} STORAGE_PHYSICAL_NODE_DATA, *PSTORAGE_PHYSICAL_NODE_DATA;

typedef struct _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD NodeCount;
    DWORD Reserved;
    STORAGE_PHYSICAL_NODE_DATA Node[ANYSIZE_ARRAY];
} STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR, *PSTORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;

typedef struct _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD LunMaxIoCount;
    DWORD AdapterMaxIoCount;
} STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR, *PSTORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;

typedef struct _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DWORD64 Attributes;
} STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR, *PSTORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;

#define STORAGE_ATTRIBUTE_BYTE_ADDRESSABLE_IO  0x01
#define STORAGE_ATTRIBUTE_BLOCK_IO  0x02
#define STORAGE_ATTRIBUTE_DYNAMIC_PERSISTENCE  0x04
#define STORAGE_ATTRIBUTE_VOLATILE  0x08
#define STORAGE_ATTRIBUTE_ASYNC_EVENT_NOTIFICATION  0x10

typedef enum _STORAGE_DISK_HEALTH_STATUS {
    DiskHealthUnknown = 0,
    DiskHealthUnhealthy,
    DiskHealthWarning,
    DiskHealthHealthy,
    DiskHealthMax
} STORAGE_DISK_HEALTH_STATUS, *PSTORAGE_DISK_HEALTH_STATUS;

typedef enum _STORAGE_DISK_OPERATIONAL_STATUS {
    DiskOpStatusNone = 0,
    DiskOpStatusUnknown,
    DiskOpStatusOk,
    DiskOpStatusPredictingFailure,
    DiskOpStatusInService,
    DiskOpStatusHardwareError,
    DiskOpStatusNotUsable,
    DiskOpStatusTransientError,
    DiskOpStatusMissing,
} STORAGE_DISK_OPERATIONAL_STATUS, *PSTORAGE_DISK_OPERATIONAL_STATUS;

typedef enum _STORAGE_OPERATIONAL_STATUS_REASON {
    DiskOpReasonUnknown = 0,
    DiskOpReasonScsiSenseCode,
    DiskOpReasonMedia,
    DiskOpReasonIo,
    DiskOpReasonThresholdExceeded,
    DiskOpReasonLostData,
    DiskOpReasonEnergySource,
    DiskOpReasonConfiguration,
    DiskOpReasonDeviceController,
    DiskOpReasonMediaController,
    DiskOpReasonComponent,
    DiskOpReasonNVDIMM_N,
    DiskOpReasonBackgroundOperation,
    DiskOpReasonInvalidFirmware,
    DiskOpReasonHealthCheck,
    DiskOpReasonLostDataPersistence,
    DiskOpReasonDisabledByPlatform
} STORAGE_OPERATIONAL_STATUS_REASON, *PSTORAGE_OPERATIONAL_STATUS_REASON;

typedef struct _STORAGE_OPERATIONAL_REASON {
    DWORD Version;
    DWORD Size;
    STORAGE_OPERATIONAL_STATUS_REASON Reason;

    union {
        struct {
            BYTE SenseKey;
            BYTE ASC;
            BYTE ASCQ;
            BYTE Reserved;
        } ScsiSenseKey;
        struct {
            BYTE CriticalHealth;
            BYTE ModuleHealth[2];
            BYTE ErrorThresholdStatus;
        } NVDIMM_N;

        DWORD AsUlong;
    } RawBytes;
} STORAGE_OPERATIONAL_REASON, *PSTORAGE_OPERATIONAL_REASON;

#define STORAGE_DEVICE_MAX_OPERATIONAL_STATUS  16

typedef struct _STORAGE_DEVICE_MANAGEMENT_STATUS {
    DWORD Version;
    DWORD Size;
    STORAGE_DISK_HEALTH_STATUS Health;
    DWORD NumberOfOperationalStatus;
    DWORD NumberOfAdditionalReasons;
    STORAGE_DISK_OPERATIONAL_STATUS OperationalStatus[STORAGE_DEVICE_MAX_OPERATIONAL_STATUS];
    STORAGE_OPERATIONAL_REASON AdditionalReasons[ANYSIZE_ARRAY];
} STORAGE_DEVICE_MANAGEMENT_STATUS, *PSTORAGE_DEVICE_MANAGEMENT_STATUS;

#define STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH (128)

typedef struct _STORAGE_ADAPTER_SERIAL_NUMBER {
    DWORD Version;
    DWORD Size;
    WCHAR SerialNumber[STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH];
} STORAGE_ADAPTER_SERIAL_NUMBER, *PSTORAGE_ADAPTER_SERIAL_NUMBER;

#define STORAGE_ADAPTER_SERIAL_NUMBER_V1_VERSION (sizeof(STORAGE_ADAPTER_SERIAL_NUMBER))
#define STORAGE_ADAPTER_SERIAL_NUMBER_V1_SIZE (sizeof(STORAGE_ADAPTER_SERIAL_NUMBER))

typedef struct _DEVICE_LOCATION {
    DWORD Socket;
    DWORD Slot;
    DWORD Adapter;
    DWORD Port;
    union {
        struct {
            DWORD Channel;
            DWORD Device;
        } DUMMYSTRUCTNAME;
        struct {
            DWORD Target;
            DWORD Lun;
        } DUMMYSTRUCTNAME2;
    } DUMMYUNIONNAME;
} DEVICE_LOCATION, *PDEVICE_LOCATION;

typedef struct _STORAGE_DEVICE_LOCATION_DESCRIPTOR {
    DWORD Version;
    DWORD Size;
    DEVICE_LOCATION Location;
    DWORD StringOffset;
} STORAGE_DEVICE_LOCATION_DESCRIPTOR, *PSTORAGE_DEVICE_LOCATION_DESCRIPTOR;

#define DeviceDsmActionFlag_NonDestructive  0x80000000

#define IsDsmActionNonDestructive(_Action) ((BOOLEAN)((_Action & DeviceDsmActionFlag_NonDestructive) != 0))

typedef DWORD DEVICE_DATA_MANAGEMENT_SET_ACTION;

#define DeviceDsmAction_None  0
#define DeviceDsmAction_Trim  1
#define DeviceDsmAction_Notification  ( 2  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_OffloadRead  ( 3  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_OffloadWrite  4
#define DeviceDsmAction_Allocation  ( 5  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_Repair  ( 6  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_Scrub  ( 7  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_DrtQuery  ( 8  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_DrtClear  ( 9  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_DrtDisable  (10  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_TieringQuery  (11  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_Map  (12  | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_RegenerateParity  (13  | DeviceDsmActionFlag_NonDestructive)

#define DeviceDsmAction_NvCache_Change_Priority (14 | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_NvCache_Evict  (15 | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_TopologyIdQuery  (16 | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_GetPhysicalAddresses  (17 | DeviceDsmActionFlag_NonDestructive)
#define DeviceDsmAction_ScopeRegen  (18 | DeviceDsmActionFlag_NonDestructive)

#define DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE  0x00000001
#define DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED  0x80000000
#define DEVICE_DSM_FLAG_ALLOCATION_CONSOLIDATEABLE_ONLY  0x40000000
#define DEVICE_DSM_FLAG_SCRUB_SKIP_IN_SYNC  0x10000000
#define DEVICE_DSM_FLAG_SCRUB_OUTPUT_PARITY_EXTENT  0x20000000
#define DEVICE_DSM_FLAG_REPAIR_OUTPUT_PARITY_EXTENT  0x20000000
#define DEVICE_DSM_FLAG_REPAIR_INPUT_TOPOLOGY_ID_PRESENT 0x40000000
#define DEVICE_DSM_FLAG_PHYSICAL_ADDRESSES_OMIT_TOTAL_RANGES 0x10000000

typedef struct _DEVICE_DATA_SET_RANGE {
    LONGLONG StartingOffset;
    DWORDLONG LengthInBytes;
} DEVICE_DATA_SET_RANGE, *PDEVICE_DATA_SET_RANGE;

typedef struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES {
    DWORD Size;
    DEVICE_DATA_MANAGEMENT_SET_ACTION Action;
    DWORD Flags;
    DWORD ParameterBlockOffset;
    DWORD ParameterBlockLength;
    DWORD DataSetRangesOffset;
    DWORD DataSetRangesLength;
} DEVICE_MANAGE_DATA_SET_ATTRIBUTES, *PDEVICE_MANAGE_DATA_SET_ATTRIBUTES;

typedef struct _DEVICE_DSM_NOTIFICATION_PARAMETERS {
    DWORD Size;
    DWORD Flags;
    DWORD NumFileTypeIDs;
    GUID FileTypeID[1];
} DEVICE_DSM_NOTIFICATION_PARAMETERS, *PDEVICE_DSM_NOTIFICATION_PARAMETERS;

#define DEVICE_DSM_NOTIFY_FLAG_BEGIN  0x00000001
#define DEVICE_DSM_NOTIFY_FLAG_END  0x00000002

typedef struct _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS {
    DWORD Size;
    BYTE TargetPriority;
    BYTE Reserved[3];
} DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS, *PDEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS;

#define STORAGE_OFFLOAD_MAX_TOKEN_LENGTH  512
#define STORAGE_OFFLOAD_TOKEN_ID_LENGTH  0x1F8
#define STORAGE_OFFLOAD_TOKEN_TYPE_ZERO_DATA  0xFFFF0001

typedef struct _STORAGE_OFFLOAD_TOKEN {
    BYTE TokenType[4];
    BYTE Reserved[2];
    BYTE TokenIdLength[2];
    union {
        struct {
            BYTE Reserved2[STORAGE_OFFLOAD_TOKEN_ID_LENGTH];
        } StorageOffloadZeroDataToken;
        BYTE Token[STORAGE_OFFLOAD_TOKEN_ID_LENGTH];
    } DUMMYUNIONNAME;
} STORAGE_OFFLOAD_TOKEN, *PSTORAGE_OFFLOAD_TOKEN;

#define MAKE_ZERO_TOKEN(T) (  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenType[0] = 0xFF,  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenType[1] = 0xFF,  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenType[2] = 0x00,  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenType[3] = 0x01,  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenIdLength[0] = 0x01,  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenIdLength[1] = 0xF8  \
)

#define IS_ZERO_TOKEN(T) (  \
  (((PSTORAGE_OFFLOAD_TOKEN)T)->TokenType[0] == 0xFF  &&  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenType[1] == 0xFF  &&  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenType[2] == 0x00  &&  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenType[3] == 0x01  &&  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenIdLength[0] == 0x01 &&  \
  ((PSTORAGE_OFFLOAD_TOKEN)T)->TokenIdLength[1] == 0xF8)  \
)

typedef struct _DEVICE_DSM_OFFLOAD_READ_PARAMETERS {
    DWORD Flags;
    DWORD TimeToLive;
    DWORD Reserved[2];
} DEVICE_DSM_OFFLOAD_READ_PARAMETERS, *PDEVICE_DSM_OFFLOAD_READ_PARAMETERS;

typedef struct _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS {
    DWORD Flags;
    DWORD Reserved;
    DWORDLONG TokenOffset;
    STORAGE_OFFLOAD_TOKEN Token;
} DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS, *PDEVICE_DSM_OFFLOAD_WRITE_PARAMETERS;

#define GET_REPAIR_TOPOLOGY_ID(R) \
  RtlOffsetToPointer( R, \
  ALIGN_UP_BY( FIELD_OFFSET( DEVICE_DATA_SET_REPAIR_PARAMETERS, RepairCopies ) + \
  sizeof( DWORD ) * R->NumberOfRepairCopies, \
  8 ) )

typedef struct _DEVICE_DATA_SET_REPAIR_PARAMETERS {
    DWORD NumberOfRepairCopies;
    DWORD SourceCopy;
    DWORD RepairCopies[ANYSIZE_ARRAY];
} DEVICE_DATA_SET_REPAIR_PARAMETERS, *PDEVICE_DATA_SET_REPAIR_PARAMETERS;

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

typedef struct _DEVICE_DATA_SET_LBP_STATE_PARAMETERS {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    DWORD OutputVersion;
} DEVICE_DATA_SET_LBP_STATE_PARAMETERS, *PDEVICE_DATA_SET_LBP_STATE_PARAMETERS;

#define DEVICE_DATA_SET_LBP_STATE_PARAMETERS_VERSION_V1  1

#endif /* NTDDI_VERSION >= NTDDI_WINBLUE */

typedef struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT {
    DWORD Size;
    DEVICE_DATA_MANAGEMENT_SET_ACTION Action;
    DWORD Flags;
    DWORD OperationStatus;
    DWORD ExtendedError;
    DWORD TargetDetailedError;
    DWORD ReservedStatus;
    DWORD OutputBlockOffset;
    DWORD OutputBlockLength;
} DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT, *PDEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;

typedef struct _DEVICE_DATA_SET_LB_PROVISIONING_STATE {
    DWORD Size;
    DWORD Version;
    DWORDLONG SlabSizeInBytes;
    DWORD SlabOffsetDeltaInBytes;
    DWORD SlabAllocationBitMapBitCount;
    DWORD SlabAllocationBitMapLength;
    DWORD SlabAllocationBitMap[ANYSIZE_ARRAY];
} DEVICE_DATA_SET_LB_PROVISIONING_STATE, *PDEVICE_DATA_SET_LB_PROVISIONING_STATE;

#define DEVICE_DATA_SET_LB_PROVISIONING_STATE_VERSION_V1  (sizeof(DEVICE_DATA_SET_LB_PROVISIONING_STATE))

#if (NTDDI_VERSION >= NTDDI_WINBLUE)

typedef struct _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 {

    DWORD Size;
    DWORD Version;
    DWORDLONG SlabSizeInBytes;
    DWORDLONG SlabOffsetDeltaInBytes;
    DWORD SlabAllocationBitMapBitCount;
    DWORD SlabAllocationBitMapLength;
    DWORD SlabAllocationBitMap[ANYSIZE_ARRAY];

} DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2, *PDEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;

#define DEVICE_DATA_SET_LB_PROVISIONING_STATE_VERSION_V2 (sizeof(DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2))

#endif /* NTDDI_VERSION >= NTDDI_WINBLUE */

typedef struct _STORAGE_OFFLOAD_READ_OUTPUT {
    DWORD OffloadReadFlags;
    DWORD Reserved;
    DWORDLONG LengthProtected;
    DWORD TokenLength;
    STORAGE_OFFLOAD_TOKEN Token;
} STORAGE_OFFLOAD_READ_OUTPUT, *PSTORAGE_OFFLOAD_READ_OUTPUT;

#define STORAGE_OFFLOAD_READ_RANGE_TRUNCATED (0x0001)

typedef struct _STORAGE_OFFLOAD_WRITE_OUTPUT {
    DWORD OffloadWriteFlags;
    DWORD Reserved;
    DWORDLONG LengthCopied;
} STORAGE_OFFLOAD_WRITE_OUTPUT, *PSTORAGE_OFFLOAD_WRITE_OUTPUT;

#define STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED (0x0001)
#define STORAGE_OFFLOAD_TOKEN_INVALID  (0x0002)

typedef struct _DEVICE_DATA_SET_SCRUB_OUTPUT {
    DWORDLONG BytesProcessed;
    DWORDLONG BytesRepaired;
    DWORDLONG BytesFailed;
} DEVICE_DATA_SET_SCRUB_OUTPUT, *PDEVICE_DATA_SET_SCRUB_OUTPUT;

typedef struct _DEVICE_DATA_SET_SCRUB_EX_OUTPUT {
    DWORDLONG BytesProcessed;
    DWORDLONG BytesRepaired;
    DWORDLONG BytesFailed;
    DEVICE_DATA_SET_RANGE ParityExtent;
} DEVICE_DATA_SET_SCRUB_EX_OUTPUT, *PDEVICE_DATA_SET_SCRUB_EX_OUTPUT;

typedef struct _DEVICE_DATA_SET_REPAIR_OUTPUT {
    DEVICE_DATA_SET_RANGE ParityExtent;
} DEVICE_DATA_SET_REPAIR_OUTPUT, *PDEVICE_DATA_SET_REPAIR_OUTPUT;

typedef struct _DEVICE_DSM_TIERING_QUERY_INPUT {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    DWORD NumberOfTierIds;
    GUID TierIds[ANYSIZE_ARRAY];
} DEVICE_DSM_TIERING_QUERY_INPUT, *PDEVICE_DSM_TIERING_QUERY_INPUT;

typedef struct _STORAGE_TIER_REGION {
    GUID TierId;
    DWORDLONG Offset;
    DWORDLONG Length;
} STORAGE_TIER_REGION, *PSTORAGE_TIER_REGION;

typedef struct _DEVICE_DSM_TIERING_QUERY_OUTPUT {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    DWORD Reserved;
    DWORDLONG Alignment;
    DWORD TotalNumberOfRegions;
    DWORD NumberOfRegionsReturned;
    STORAGE_TIER_REGION Regions[ANYSIZE_ARRAY];
} DEVICE_DSM_TIERING_QUERY_OUTPUT, *PDEVICE_DSM_TIERING_QUERY_OUTPUT;

typedef struct _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT {
    DWORDLONG TopologyRangeBytes;
    BYTE TopologyId[16];
} DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT, *PDEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;

typedef struct _DEVICE_STORAGE_ADDRESS_RANGE {
    LONGLONG StartAddress;
    DWORDLONG LengthInBytes;
} DEVICE_STORAGE_ADDRESS_RANGE, *PDEVICE_STORAGE_ADDRESS_RANGE;

#define DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_VERSION_V1  1

typedef struct _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT {
    DWORD Version;
    DWORD Flags;
    DWORD TotalNumberOfRanges;
    DWORD NumberOfRangesReturned;
    DEVICE_STORAGE_ADDRESS_RANGE Ranges[ANYSIZE_ARRAY];
} DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT, *PDEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT;

typedef struct _STORAGE_GET_BC_PROPERTIES_OUTPUT {
    DWORD MaximumRequestsPerPeriod;
    DWORD MinimumPeriod;
    DWORDLONG MaximumRequestSize;
    DWORD EstimatedTimePerRequest;
    DWORD NumOutStandingRequests;
    DWORDLONG RequestSize;
} STORAGE_GET_BC_PROPERTIES_OUTPUT, *PSTORAGE_GET_BC_PROPERTIES_OUTPUT;

#define IOCTL_STORAGE_BC_VERSION  1

typedef struct _STORAGE_ALLOCATE_BC_STREAM_INPUT {
    DWORD Version;
    DWORD RequestsPerPeriod;
    DWORD Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    BOOLEAN Reserved1[2];
    DWORD AccessType;
    DWORD AccessMode;
} STORAGE_ALLOCATE_BC_STREAM_INPUT, *PSTORAGE_ALLOCATE_BC_STREAM_INPUT;

typedef struct _STORAGE_ALLOCATE_BC_STREAM_OUTPUT {
    DWORDLONG RequestSize;
    DWORD NumOutStandingRequests;
} STORAGE_ALLOCATE_BC_STREAM_OUTPUT, *PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT;

#define STORAGE_PRIORITY_HINT_SUPPORTED  0x0001

typedef struct _STORAGE_PRIORITY_HINT_SUPPORT {
    DWORD SupportFlags;
} STORAGE_PRIORITY_HINT_SUPPORT, *PSTORAGE_PRIORITY_HINT_SUPPORT;

#if defined(_MSC_EXTENSIONS)
typedef struct _STORAGE_MEDIA_SERIAL_NUMBER_DATA {
    WORD Reserved;
    WORD SerialNumberLength;
    BYTE SerialNumber[0];
} STORAGE_MEDIA_SERIAL_NUMBER_DATA, *PSTORAGE_MEDIA_SERIAL_NUMBER_DATA;
#endif /* _MSC_EXTENSIONS */

typedef struct _STORAGE_READ_CAPACITY {
    DWORD Version;
    DWORD Size;
    DWORD BlockLength;
    LARGE_INTEGER NumberOfBlocks;
    LARGE_INTEGER DiskLength;
} STORAGE_READ_CAPACITY, *PSTORAGE_READ_CAPACITY;

typedef enum _WRITE_CACHE_TYPE {
    WriteCacheTypeUnknown,
    WriteCacheTypeNone,
    WriteCacheTypeWriteBack,
    WriteCacheTypeWriteThrough
} WRITE_CACHE_TYPE;

typedef enum _WRITE_CACHE_ENABLE {
    WriteCacheEnableUnknown,
    WriteCacheDisabled,
    WriteCacheEnabled
} WRITE_CACHE_ENABLE;

typedef enum _WRITE_CACHE_CHANGE {
    WriteCacheChangeUnknown,
    WriteCacheNotChangeable,
    WriteCacheChangeable
} WRITE_CACHE_CHANGE;

typedef enum _WRITE_THROUGH {
    WriteThroughUnknown,
    WriteThroughNotSupported,
    WriteThroughSupported
} WRITE_THROUGH;

typedef struct _STORAGE_WRITE_CACHE_PROPERTY {
    DWORD Version;
    DWORD Size;
    WRITE_CACHE_TYPE WriteCacheType;
    WRITE_CACHE_ENABLE WriteCacheEnabled;
    WRITE_CACHE_CHANGE WriteCacheChangeable;
    WRITE_THROUGH WriteThroughSupported;
    BOOLEAN FlushCacheSupported;
    BOOLEAN UserDefinedPowerProtection;
    BOOLEAN NVCacheEnabled;
} STORAGE_WRITE_CACHE_PROPERTY, *PSTORAGE_WRITE_CACHE_PROPERTY;

#if defined(_MSC_EXTENSIONS)
typedef struct _PERSISTENT_RESERVE_COMMAND {
    DWORD Version;
    DWORD Size;
    union {
        struct {
            BYTE ServiceAction:5;
            BYTE Reserved1:3;
            WORD AllocationLength;
        } PR_IN;
        struct {
            BYTE ServiceAction:5;
            BYTE Reserved1:3;
            BYTE Type:4;
            BYTE Scope:4;
            BYTE ParameterList[0];
        } PR_OUT;
    } DUMMYUNIONNAME;
} PERSISTENT_RESERVE_COMMAND, *PPERSISTENT_RESERVE_COMMAND;
#endif /* _MSC_EXTENSIONS */

#define DEVICEDUMP_STRUCTURE_VERSION_V1  1

#define DEVICEDUMP_MAX_IDSTRING 32
#define MAX_FW_BUCKET_ID_LENGTH 132

#define STORAGE_CRASH_TELEMETRY_REGKEY  L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\CrashControl\\StorageTelemetry"
#define STORAGE_DEVICE_TELEMETRY_REGKEY L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Storage\\StorageTelemetry"

typedef enum _DEVICEDUMP_COLLECTION_TYPE {
    TCCollectionBugCheck = 1,
    TCCollectionApplicationRequested,
    TCCollectionDeviceRequested
} DEVICEDUMP_COLLECTION_TYPEIDE_NOTIFICATION_TYPE, *PDEVICEDUMP_COLLECTION_TYPE;

#define DDUMP_FLAG_DATA_READ_FROM_DEVICE  0x0001

#define FW_ISSUEID_NO_ISSUE  0x00000000
#define FW_ISSUEID_UNKNOWN  0xFFFFFFFF

#include <pshpack1.h> 

typedef struct _DEVICEDUMP_SUBSECTION_POINTER {
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwOffset;
} DEVICEDUMP_SUBSECTION_POINTER, *PDEVICEDUMP_SUBSECTION_POINTER;

typedef struct _DEVICEDUMP_STRUCTURE_VERSION {
    DWORD dwSignature;
    DWORD dwVersion;
    DWORD dwSize;
} DEVICEDUMP_STRUCTURE_VERSION, *PDEVICEDUMP_STRUCTURE_VERSION;

typedef struct _DEVICEDUMP_SECTION_HEADER {
    GUID guidDeviceDataId;
    BYTE sOrganizationID[16];
    DWORD dwFirmwareRevision;
    BYTE sModelNumber[DEVICEDUMP_MAX_IDSTRING];
    BYTE szDeviceManufacturingID[DEVICEDUMP_MAX_IDSTRING];
    DWORD dwFlags;
    DWORD bRestrictedPrivateDataVersion;
    DWORD dwFirmwareIssueId;
    BYTE szIssueDescriptionString[MAX_FW_BUCKET_ID_LENGTH];
} DEVICEDUMP_SECTION_HEADER, *PDEVICEDUMP_SECTION_HEADER;

#define TC_PUBLIC_DEVICEDUMP_CONTENT_SMART  0x01
#define TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG  0x02

#define TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX  16

#define TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH  16

#define TC_PUBLIC_DATA_TYPE_ATAGP "ATAGPLogPages"
#define TC_PUBLIC_DATA_TYPE_ATASMART "ATASMARTPages"

typedef struct _GP_LOG_PAGE_DESCRIPTOR {
    WORD LogAddress;
    WORD LogSectors;
} GP_LOG_PAGE_DESCRIPTOR, *PGP_LOG_PAGE_DESCRIPTOR;

typedef struct _DEVICEDUMP_PUBLIC_SUBSECTION {
    DWORD dwFlags;
    GP_LOG_PAGE_DESCRIPTOR GPLogTable[TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX];
    CHAR szDescription[TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH];
    BYTE bData[ANYSIZE_ARRAY];
} DEVICEDUMP_PUBLIC_SUBSECTION, *PDEVICEDUMP_PUBLIC_SUBSECTION;

typedef struct _DEVICEDUMP_RESTRICTED_SUBSECTION {
    BYTE bData[ANYSIZE_ARRAY];
} DEVICEDUMP_RESTRICTED_SUBSECTION, *PDEVICEDUMP_RESTRICTED_SUBSECTION;

typedef struct _DEVICEDUMP_PRIVATE_SUBSECTION {
    DWORD dwFlags;
    GP_LOG_PAGE_DESCRIPTOR GPLogId;
    BYTE bData[ANYSIZE_ARRAY];
} DEVICEDUMP_PRIVATE_SUBSECTION, *PDEVICEDUMP_PRIVATE_SUBSECTION;

typedef struct _DEVICEDUMP_STORAGEDEVICE_DATA {
    DEVICEDUMP_STRUCTURE_VERSION Descriptor;
    DEVICEDUMP_SECTION_HEADER SectionHeader;
    DWORD dwBufferSize;
    DWORD dwReasonForCollection;
    DEVICEDUMP_SUBSECTION_POINTER PublicData;
    DEVICEDUMP_SUBSECTION_POINTER RestrictedData;
    DEVICEDUMP_SUBSECTION_POINTER PrivateData;
} DEVICEDUMP_STORAGEDEVICE_DATA, *PDEVICEDUMP_STORAGEDEVICE_DATA;

#define CDB_SIZE  16
#define TELEMETRY_COMMAND_SIZE  16

#define TCRecordStorportSrbFunction  Command[0]

typedef struct _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD {
    BYTE Cdb[CDB_SIZE];
    BYTE Command[TELEMETRY_COMMAND_SIZE];
    DWORDLONG StartTime;
    DWORDLONG EndTime;
    DWORD OperationStatus;
    DWORD OperationError;
    union {
        struct {
            DWORD dwReserved;
        } ExternalStack;

        struct {
            DWORD dwAtaPortSpecific;
        } AtaPort;

        struct {
            DWORD SrbTag;
        } StorPort;
    } StackSpecific;
} DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD, *PDEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD;

typedef struct _DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP {
    DEVICEDUMP_STRUCTURE_VERSION Descriptor;
    DWORD dwReasonForCollection;
    BYTE cDriverName[16];
    DWORD uiNumRecords;
    DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD RecordArray[ANYSIZE_ARRAY];
} DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP, *PDEVICEDUMP_STORAGESTACK_PUBLIC_DUMP;

#include <poppack.h>

#define DEVICEDUMP_CAP_PRIVATE_SECTION  0x00000001
#define DEVICEDUMP_CAP_RESTRICTED_SECTION  0x00000002

typedef struct _STORAGE_IDLE_POWER {
    DWORD Version;
    DWORD Size;
    DWORD WakeCapableHint:1;
    DWORD D3ColdSupported:1;
    DWORD Reserved:30;
    DWORD D3IdleTimeout;
} STORAGE_IDLE_POWER, *PSTORAGE_IDLE_POWER;

typedef enum _STORAGE_POWERUP_REASON_TYPE {
    StoragePowerupUnknown = 0,
    StoragePowerupIO,
    StoragePowerupDeviceAttention
} STORAGE_POWERUP_REASON_TYPE, *PSTORAGE_POWERUP_REASON_TYPE;

typedef struct _STORAGE_IDLE_POWERUP_REASON {
    DWORD Version;
    DWORD Size;
    STORAGE_POWERUP_REASON_TYPE PowerupReason;
} STORAGE_IDLE_POWERUP_REASON, *PSTORAGE_IDLE_POWERUP_REASON;

#define STORAGE_IDLE_POWERUP_REASON_VERSION_V1  1

typedef enum _STORAGE_DEVICE_POWER_CAP_UNITS {
    StorageDevicePowerCapUnitsPercent,
    StorageDevicePowerCapUnitsMilliwatts
} STORAGE_DEVICE_POWER_CAP_UNITS, *PSTORAGE_DEVICE_POWER_CAP_UNITS;

typedef struct _STORAGE_DEVICE_POWER_CAP {
    DWORD Version;
    DWORD Size;
    STORAGE_DEVICE_POWER_CAP_UNITS Units;
    DWORDLONG MaxPower;
} STORAGE_DEVICE_POWER_CAP, *PSTORAGE_DEVICE_POWER_CAP;

#define STORAGE_DEVICE_POWER_CAP_VERSION_V1  1

#include <pshpack1.h> 

typedef struct _STORAGE_RPMB_DATA_FRAME {
    BYTE Stuff[196];
    BYTE KeyOrMAC[32];
    BYTE Data[256];
    BYTE Nonce[16];
    BYTE WriteCounter[4];
    BYTE Address[2];
    BYTE BlockCount[2];
    BYTE OperationResult[2];
    BYTE RequestOrResponseType[2];
} STORAGE_RPMB_DATA_FRAME, *PSTORAGE_RPMB_DATA_FRAME;

typedef enum _STORAGE_RPMB_COMMAND_TYPE {
    StorRpmbProgramAuthKey = 0x00000001,
    StorRpmbQueryWriteCounter = 0x00000002,
    StorRpmbAuthenticatedWrite = 0x00000003,
    StorRpmbAuthenticatedRead = 0x00000004,
    StorRpmbReadResultRequest = 0x00000005,
    StorRpmbAuthenticatedDeviceConfigWrite = 0x00000006,
    StorRpmbAuthenticatedDeviceConfigRead = 0x00000007,
} STORAGE_RPMB_COMMAND_TYPE, *PSTORAGE_RPMB_COMMAND_TYPE;

#include <poppack.h>

typedef struct _STORAGE_EVENT_NOTIFICATION {
    DWORD Version;
    DWORD Size;
    DWORDLONG Events;
} STORAGE_EVENT_NOTIFICATION, *PSTORAGE_EVENT_NOTIFICATION;

#define STORAGE_EVENT_NOTIFICATION_VERSION_V1  1

#define STORAGE_EVENT_MEDIA_STATUS  0x0000000000000001
#define STORAGE_EVENT_DEVICE_STATUS  0x0000000000000002
#define STORAGE_EVENT_DEVICE_OPERATION  0x0000000000000004

#define STORAGE_EVENT_ALL (STORAGE_EVENT_MEDIA_STATUS | STORAGE_EVENT_DEVICE_STATUS | STORAGE_EVENT_DEVICE_OPERATION)

#define READ_COPY_NUMBER_KEY  0x52434e00  /* 'RCN' */

#define IsKeyReadCopyNumber(_k)  (((_k) & 0xFFFFFF00) == READ_COPY_NUMBER_KEY)

#define ReadCopyNumberToKey(_c)  (READ_COPY_NUMBER_KEY | (BYTE )(_c))
#define ReadCopyNumberFromKey(_k)  (BYTE )((_k) & 0x000000FF)

typedef enum _STORAGE_COUNTER_TYPE {
    StorageCounterTypeUnknown = 0,
    StorageCounterTypeTemperatureCelsius,
    StorageCounterTypeTemperatureCelsiusMax,
    StorageCounterTypeReadErrorsTotal,
    StorageCounterTypeReadErrorsCorrected,
    StorageCounterTypeReadErrorsUncorrected,
    StorageCounterTypeWriteErrorsTotal,
    StorageCounterTypeWriteErrorsCorrected,
    StorageCounterTypeWriteErrorsUncorrected,
    StorageCounterTypeManufactureDate,
    StorageCounterTypeStartStopCycleCount,
    StorageCounterTypeStartStopCycleCountMax,
    StorageCounterTypeLoadUnloadCycleCount,
    StorageCounterTypeLoadUnloadCycleCountMax,
    StorageCounterTypeWearPercentage,
    StorageCounterTypeWearPercentageWarning,
    StorageCounterTypeWearPercentageMax,
    StorageCounterTypePowerOnHours,
    StorageCounterTypeReadLatency100NSMax,
    StorageCounterTypeWriteLatency100NSMax,
    StorageCounterTypeFlushLatency100NSMax,
    StorageCounterTypeMax
} STORAGE_COUNTER_TYPE, *PSTORAGE_COUNTER_TYPE;

typedef struct _STORAGE_COUNTER {
    STORAGE_COUNTER_TYPE Type;
    union {

        struct {
            DWORD Week;

            DWORD Year;
        } ManufactureDate;
        DWORDLONG AsUlonglong;
    } Value;

} STORAGE_COUNTER, *PSTORAGE_COUNTER;

typedef struct _STORAGE_COUNTERS {
    DWORD Version;
    DWORD Size;
    DWORD NumberOfCounters;
    STORAGE_COUNTER Counters[ANYSIZE_ARRAY];
} STORAGE_COUNTERS, *PSTORAGE_COUNTERS;

#define STORAGE_COUNTERS_VERSION_V1 sizeof(STORAGE_COUNTERS)

#define STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER  0x00000001

#define STORAGE_HW_FIRMWARE_REQUEST_FLAG_SWITCH_TO_EXISTING_FIRMWARE  0x80000000

typedef struct _STORAGE_HW_FIRMWARE_INFO_QUERY {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    DWORD Reserved;
} STORAGE_HW_FIRMWARE_INFO_QUERY, *PSTORAGE_HW_FIRMWARE_INFO_QUERY;

#define STORAGE_HW_FIRMWARE_INVALID_SLOT  0xFF

#define STORAGE_HW_FIRMWARE_REVISION_LENGTH  16

typedef struct _STORAGE_HW_FIRMWARE_SLOT_INFO {
    DWORD Version;
    DWORD Size;
    BYTE SlotNumber;
    BYTE ReadOnly:1;
    BYTE Reserved0:7;
    BYTE Reserved1[6];
    BYTE Revision[STORAGE_HW_FIRMWARE_REVISION_LENGTH];
} STORAGE_HW_FIRMWARE_SLOT_INFO, *PSTORAGE_HW_FIRMWARE_SLOT_INFO;

typedef struct _STORAGE_HW_FIRMWARE_INFO {
    DWORD Version;
    DWORD Size;
    BYTE SupportUpgrade:1;
    BYTE Reserved0:7;
    BYTE SlotCount;
    BYTE ActiveSlot;
    BYTE PendingActivateSlot;
    BOOLEAN FirmwareShared;
    BYTE Reserved[3];
    DWORD ImagePayloadAlignment;
    DWORD ImagePayloadMaxSize;
    STORAGE_HW_FIRMWARE_SLOT_INFO Slot[ANYSIZE_ARRAY];
} STORAGE_HW_FIRMWARE_INFO, *PSTORAGE_HW_FIRMWARE_INFO;

typedef struct _STORAGE_HW_FIRMWARE_DOWNLOAD {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    BYTE Slot;
    BYTE Reserved[3];
    DWORDLONG Offset;
    DWORDLONG BufferSize;
    BYTE ImageBuffer[ANYSIZE_ARRAY];
} STORAGE_HW_FIRMWARE_DOWNLOAD, *PSTORAGE_HW_FIRMWARE_DOWNLOAD;

typedef struct _STORAGE_HW_FIRMWARE_ACTIVATE {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    BYTE Slot;
    BYTE Reserved0[3];
} STORAGE_HW_FIRMWARE_ACTIVATE, *PSTORAGE_HW_FIRMWARE_ACTIVATE;

#define STORAGE_PROTOCOL_STRUCTURE_VERSION  0x1

typedef struct _STORAGE_PROTOCOL_COMMAND {
    DWORD Version;
    DWORD Length;
    STORAGE_PROTOCOL_TYPE ProtocolType;
    DWORD Flags;
    DWORD ReturnStatus;
    DWORD ErrorCode;
    DWORD CommandLength;
    DWORD ErrorInfoLength;
    DWORD DataToDeviceTransferLength;
    DWORD DataFromDeviceTransferLength;
    DWORD TimeOutValue;
    DWORD ErrorInfoOffset;
    DWORD DataToDeviceBufferOffset;
    DWORD DataFromDeviceBufferOffset;
    DWORD CommandSpecific;
    DWORD Reserved0;
    DWORD FixedProtocolReturnData;
    DWORD Reserved1[3];
    BYTE Command[ANYSIZE_ARRAY];
} STORAGE_PROTOCOL_COMMAND, *PSTORAGE_PROTOCOL_COMMAND;

#define STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST  0x80000000

#define STORAGE_PROTOCOL_STATUS_PENDING  0x0
#define STORAGE_PROTOCOL_STATUS_SUCCESS  0x1
#define STORAGE_PROTOCOL_STATUS_ERROR  0x2
#define STORAGE_PROTOCOL_STATUS_INVALID_REQUEST  0x3
#define STORAGE_PROTOCOL_STATUS_NO_DEVICE  0x4
#define STORAGE_PROTOCOL_STATUS_BUSY  0x5
#define STORAGE_PROTOCOL_STATUS_DATA_OVERRUN  0x6
#define STORAGE_PROTOCOL_STATUS_INSUFFICIENT_RESOURCES  0x7

#define STORAGE_PROTOCOL_STATUS_NOT_SUPPORTED  0xFF

#define STORAGE_PROTOCOL_COMMAND_LENGTH_NVME  0x40

#define STORAGE_PROTOCOL_SPECIFIC_NVME_ADMIN_COMMAND  0x01
#define STORAGE_PROTOCOL_SPECIFIC_NVME_NVM_COMMAND  0x02

typedef enum _STORAGE_ATTRIBUTE_MGMT_ACTION {
    StorAttributeMgmt_ClearAttribute = 0,
    StorAttributeMgmt_SetAttribute = 1,
    StorAttributeMgmt_ResetAttribute = 2
} STORAGE_ATTRIBUTE_MGMT_ACTION, *PSTORAGE_ATTRIBUTE_MGMT_ACTION;

#define STORATTRIBUTE_NONE  0

#define STORATTRIBUTE_MANAGEMENT_STATE 1

typedef struct _STORAGE_ATTRIBUTE_MGMT {
    DWORD Version;
    DWORD Size;
    STORAGE_ATTRIBUTE_MGMT_ACTION Action;
    DWORD Attribute;
} STORAGE_ATTRIBUTE_MGMT, *PSTORAGE_ATTRIBUTE_MGMT;


#endif /* _NTDDSTOR_H */


#ifndef _NTDDDISK_H
#define _NTDDDISK_H

/* #include <winapifamily.h> */

#define IOCTL_DISK_BASE  FILE_DEVICE_DISK
#define IOCTL_DISK_GET_DRIVE_GEOMETRY  CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_GET_PARTITION_INFO  CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO  CTL_CODE(IOCTL_DISK_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT  CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT  CTL_CODE(IOCTL_DISK_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_VERIFY  CTL_CODE(IOCTL_DISK_BASE, 0x0005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS  CTL_CODE(IOCTL_DISK_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_REASSIGN_BLOCKS  CTL_CODE(IOCTL_DISK_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_PERFORMANCE  CTL_CODE(IOCTL_DISK_BASE, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_IS_WRITABLE  CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_LOGGING  CTL_CODE(IOCTL_DISK_BASE, 0x000a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS_EX  CTL_CODE(IOCTL_DISK_BASE, 0x000b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_HISTOGRAM_STRUCTURE  CTL_CODE(IOCTL_DISK_BASE, 0x000c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_DATA  CTL_CODE(IOCTL_DISK_BASE, 0x000d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_RESET  CTL_CODE(IOCTL_DISK_BASE, 0x000e, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_STRUCTURE  CTL_CODE(IOCTL_DISK_BASE, 0x000f, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_DATA  CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_PERFORMANCE_OFF  CTL_CODE(IOCTL_DISK_BASE, 0x0018, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if (_WIN32_WINNT >= 0x0400)
#define IOCTL_DISK_CONTROLLER_NUMBER  CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define SMART_GET_VERSION  CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS)
#define SMART_SEND_DRIVE_COMMAND  CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define SMART_RCV_DRIVE_DATA  CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x500)
#define IOCTL_DISK_GET_PARTITION_INFO_EX  CTL_CODE(IOCTL_DISK_BASE, 0x0012, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO_EX  CTL_CODE(IOCTL_DISK_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT_EX  CTL_CODE(IOCTL_DISK_BASE, 0x0014, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT_EX  CTL_CODE(IOCTL_DISK_BASE, 0x0015, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_CREATE_DISK  CTL_CODE(IOCTL_DISK_BASE, 0x0016, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_LENGTH_INFO  CTL_CODE(IOCTL_DISK_BASE, 0x0017, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_GET_DRIVE_GEOMETRY_EX  CTL_CODE(IOCTL_DISK_BASE, 0x0028, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0502)
#define IOCTL_DISK_REASSIGN_BLOCKS_EX  CTL_CODE(IOCTL_DISK_BASE, 0x0029, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#endif /* _WIN32_WINNT >= 0x0502 */

#if(_WIN32_WINNT >= 0x0500)
#define IOCTL_DISK_UPDATE_DRIVE_SIZE  CTL_CODE(IOCTL_DISK_BASE, 0x0032, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GROW_PARTITION  CTL_CODE(IOCTL_DISK_BASE, 0x0034, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_CACHE_INFORMATION  CTL_CODE(IOCTL_DISK_BASE, 0x0035, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_CACHE_INFORMATION  CTL_CODE(IOCTL_DISK_BASE, 0x0036, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#if (NTDDI_VERSION < NTDDI_WS03)
#define IOCTL_DISK_GET_WRITE_CACHE_STATE  CTL_CODE(IOCTL_DISK_BASE, 0x0037, METHOD_BUFFERED, FILE_READ_ACCESS)
#else /* NTDDI_VERSION >= NTDDI_WS03 */
#define OBSOLETE_DISK_GET_WRITE_CACHE_STATE CTL_CODE(IOCTL_DISK_BASE, 0x0037, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif /* NTDDI_VERSION >= NTDDI_WS03 */
#define IOCTL_DISK_DELETE_DRIVE_LAYOUT  CTL_CODE(IOCTL_DISK_BASE, 0x0040, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_UPDATE_PROPERTIES  CTL_CODE(IOCTL_DISK_BASE, 0x0050, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_DRIVE  CTL_CODE(IOCTL_DISK_BASE, 0x00f3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_SENSE_DEVICE  CTL_CODE(IOCTL_DISK_BASE, 0x00f8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= 0x0500 */

#define IOCTL_DISK_CHECK_VERIFY  CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_MEDIA_REMOVAL  CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_EJECT_MEDIA  CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_LOAD_MEDIA  CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RESERVE  CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RELEASE  CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_FIND_NEW_DEVICES CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_GET_MEDIA_TYPES  CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define PARTITION_ENTRY_UNUSED  0x00
#define PARTITION_FAT_12  0x01
#define PARTITION_XENIX_1  0x02
#define PARTITION_XENIX_2  0x03
#define PARTITION_FAT_16  0x04
#define PARTITION_EXTENDED  0x05
#define PARTITION_HUGE  0x06
#define PARTITION_IFS  0x07
#define PARTITION_OS2BOOTMGR  0x0A
#define PARTITION_FAT32  0x0B
#define PARTITION_FAT32_XINT13  0x0C
#define PARTITION_XINT13  0x0E
#define PARTITION_XINT13_EXTENDED  0x0F
#define PARTITION_PREP  0x41
#define PARTITION_LDM  0x42
#define PARTITION_DM  0x54
#define PARTITION_EZDRIVE  0x55
#define PARTITION_UNIX  0x63
#define PARTITION_SPACES  0xE7
#define PARTITION_GPT  0xEE

#define VALID_NTFT  0xC0

#define PARTITION_NTFT  0x80

#if (NTDDI_VERSION < NTDDI_VISTA)
#define IsRecognizedPartition(PartitionType) (  \
  ((PartitionType & PARTITION_NTFT) && (((PartitionType & ~0xC0) == PARTITION_HUGE)  ||  \
  ((PartitionType & ~0xC0) == PARTITION_IFS)  ||  \
  ((PartitionType & ~0xC0) == PARTITION_FAT32)  ||  \
  ((PartitionType & ~0xC0) == PARTITION_FAT32_XINT13))) ||  \
  ((PartitionType) == PARTITION_FAT_12)  ||  \
  ((PartitionType) == PARTITION_FAT_16)  ||  \
  ((PartitionType) == PARTITION_HUGE)  ||  \
  ((PartitionType) == PARTITION_IFS)  ||  \
  ((PartitionType) == PARTITION_FAT32)  ||  \
  ((PartitionType) == PARTITION_FAT32_XINT13) ||  \
  ((PartitionType) == PARTITION_XINT13) )
#else /* NTDDI_VERSION >= NTDDI_VISTA */
#define IsRecognizedPartition( PartitionType ) (  \
  ((PartitionType) == PARTITION_FAT_12)  ||  \
  ((PartitionType) == PARTITION_FAT_16)  ||  \
  ((PartitionType) == PARTITION_HUGE)  ||  \
  ((PartitionType) == PARTITION_IFS)  ||  \
  ((PartitionType) == PARTITION_FAT32)  ||  \
  ((PartitionType) == PARTITION_FAT32_XINT13) ||  \
  ((PartitionType) == PARTITION_XINT13) )
#endif /* NTDDI_VERSION >= NTDDI_VISTA */

#define IsContainerPartition(PartitionType)  \
  ((PartitionType == PARTITION_EXTENDED) || (PartitionType == PARTITION_XINT13_EXTENDED))

#define IsFTPartition(PartitionType)  \
  ((PartitionType & PARTITION_NTFT) && (((PartitionType & ~0xC0) == PARTITION_HUGE)  ||  \
  ((PartitionType & ~0xC0) == PARTITION_IFS)  ||  \
  ((PartitionType & ~0xC0) == PARTITION_FAT32)  ||  \
  ((PartitionType & ~0xC0) == PARTITION_FAT32_XINT13)))

typedef enum _MEDIA_TYPE {
    Unknown,
    F5_1Pt2_512,
    F3_1Pt44_512,
    F3_2Pt88_512,
    F3_20Pt8_512,
    F3_720_512,
    F5_360_512,
    F5_320_512,
    F5_320_1024,
    F5_180_512,
    F5_160_512,
    RemovableMedia,
    FixedMedia,
    F3_120M_512,
    F3_640_512,
    F5_640_512,
    F5_720_512,
    F3_1Pt2_512,
    F3_1Pt23_1024,
    F5_1Pt23_1024,
    F3_128Mb_512,
    F3_230Mb_512,
    F8_256_128,
    F3_200Mb_512,
    F3_240M_512,
    F3_32M_512
} MEDIA_TYPE, *PMEDIA_TYPE;

typedef struct _FORMAT_PARAMETERS {
    MEDIA_TYPE MediaType;
    DWORD StartCylinderNumber;
    DWORD EndCylinderNumber;
    DWORD StartHeadNumber;
    DWORD EndHeadNumber;
} FORMAT_PARAMETERS, *PFORMAT_PARAMETERS;

typedef WORD BAD_TRACK_NUMBER;
typedef WORD *PBAD_TRACK_NUMBER;

typedef struct _FORMAT_EX_PARAMETERS {
    MEDIA_TYPE MediaType;
    DWORD StartCylinderNumber;
    DWORD EndCylinderNumber;
    DWORD StartHeadNumber;
    DWORD EndHeadNumber;
    WORD FormatGapLength;
    WORD SectorsPerTrack;
    WORD SectorNumber[1];
} FORMAT_EX_PARAMETERS, *PFORMAT_EX_PARAMETERS;

typedef struct _DISK_GEOMETRY {
    LARGE_INTEGER Cylinders;
    MEDIA_TYPE MediaType;
    DWORD TracksPerCylinder;
    DWORD SectorsPerTrack;
    DWORD BytesPerSector;
} DISK_GEOMETRY, *PDISK_GEOMETRY;

#define WMI_DISK_GEOMETRY_GUID  { 0x25007f51, 0x57c2, 0x11d1, { 0xa5, 0x28, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } }

typedef struct _PARTITION_INFORMATION {
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    DWORD HiddenSectors;
    DWORD PartitionNumber;
    BYTE PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
} PARTITION_INFORMATION, *PPARTITION_INFORMATION;

typedef struct _SET_PARTITION_INFORMATION {
    BYTE PartitionType;
} SET_PARTITION_INFORMATION, *PSET_PARTITION_INFORMATION;

typedef struct _DRIVE_LAYOUT_INFORMATION {
    DWORD PartitionCount;
    DWORD Signature;
    PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION, *PDRIVE_LAYOUT_INFORMATION;

typedef struct _VERIFY_INFORMATION {
    LARGE_INTEGER StartingOffset;
    DWORD Length;
} VERIFY_INFORMATION, *PVERIFY_INFORMATION;

typedef struct _REASSIGN_BLOCKS {
    WORD Reserved;
    WORD Count;
    DWORD BlockNumber[1];
} REASSIGN_BLOCKS, *PREASSIGN_BLOCKS;

#include <pshpack1.h>
typedef struct _REASSIGN_BLOCKS_EX {
    WORD Reserved;
    WORD Count;
    LARGE_INTEGER BlockNumber[1];
} REASSIGN_BLOCKS_EX, *PREASSIGN_BLOCKS_EX;
#include <poppack.h>

#if(_WIN32_WINNT >= 0x500)

typedef enum _PARTITION_STYLE {
    PARTITION_STYLE_MBR,
    PARTITION_STYLE_GPT,
    PARTITION_STYLE_RAW
} PARTITION_STYLE;

typedef struct _PARTITION_INFORMATION_GPT {
    GUID PartitionType;
    GUID PartitionId;
    DWORD64 Attributes;
    WCHAR Name[36];
} PARTITION_INFORMATION_GPT, *PPARTITION_INFORMATION_GPT;

#define GPT_ATTRIBUTE_PLATFORM_REQUIRED  (0x0000000000000001)

#define GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER  (0x8000000000000000)
#define GPT_BASIC_DATA_ATTRIBUTE_HIDDEN  (0x4000000000000000)
#define GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY  (0x2000000000000000)
#define GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY  (0x1000000000000000)
#define GPT_BASIC_DATA_ATTRIBUTE_OFFLINE  (0x0800000000000000)
#define GPT_BASIC_DATA_ATTRIBUTE_DAX  (0x0400000000000000)

#define GPT_SPACES_ATTRIBUTE_NO_METADATA  (0x8000000000000000)

typedef struct _PARTITION_INFORMATION_MBR {
    BYTE PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    DWORD HiddenSectors;
#if (NTDDI_VERSION >= NTDDI_WINBLUE)
    GUID PartitionId;
#endif /* NTDDI_VERSION >= NTDDI_WINBLUE */
} PARTITION_INFORMATION_MBR, *PPARTITION_INFORMATION_MBR;

typedef SET_PARTITION_INFORMATION SET_PARTITION_INFORMATION_MBR;
typedef PARTITION_INFORMATION_GPT SET_PARTITION_INFORMATION_GPT;

typedef struct _SET_PARTITION_INFORMATION_EX {
    PARTITION_STYLE PartitionStyle;
    union {
        SET_PARTITION_INFORMATION_MBR Mbr;
        SET_PARTITION_INFORMATION_GPT Gpt;
    } DUMMYUNIONNAME;
} SET_PARTITION_INFORMATION_EX, *PSET_PARTITION_INFORMATION_EX;

typedef struct _CREATE_DISK_GPT {
    GUID DiskId;
    DWORD MaxPartitionCount;
} CREATE_DISK_GPT, *PCREATE_DISK_GPT;

typedef struct _CREATE_DISK_MBR {
    DWORD Signature;
} CREATE_DISK_MBR, *PCREATE_DISK_MBR;

typedef struct _CREATE_DISK {
    PARTITION_STYLE PartitionStyle;
    union {
        CREATE_DISK_MBR Mbr;
        CREATE_DISK_GPT Gpt;
    } DUMMYUNIONNAME;
} CREATE_DISK, *PCREATE_DISK;

typedef struct _GET_LENGTH_INFORMATION {
    LARGE_INTEGER Length;
} GET_LENGTH_INFORMATION, *PGET_LENGTH_INFORMATION;

typedef struct _PARTITION_INFORMATION_EX {
    PARTITION_STYLE PartitionStyle;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    DWORD PartitionNumber;
    BOOLEAN RewritePartition;
    union {
        PARTITION_INFORMATION_MBR Mbr;
        PARTITION_INFORMATION_GPT Gpt;
    } DUMMYUNIONNAME;
} PARTITION_INFORMATION_EX, *PPARTITION_INFORMATION_EX;

typedef struct _DRIVE_LAYOUT_INFORMATION_GPT {
    GUID DiskId;
    LARGE_INTEGER StartingUsableOffset;
    LARGE_INTEGER UsableLength;
    DWORD MaxPartitionCount;
} DRIVE_LAYOUT_INFORMATION_GPT, *PDRIVE_LAYOUT_INFORMATION_GPT;

typedef struct _DRIVE_LAYOUT_INFORMATION_MBR {
    DWORD Signature;
#if (NTDDI_VERSION >= NTDDI_WIN10_RS1)
    DWORD CheckSum;
#endif /* NTDDI_VERSION >= NTDDI_WIN10_RS1 */
} DRIVE_LAYOUT_INFORMATION_MBR, *PDRIVE_LAYOUT_INFORMATION_MBR;

typedef struct _DRIVE_LAYOUT_INFORMATION_EX {
    DWORD PartitionStyle;
    DWORD PartitionCount;
    union {
        DRIVE_LAYOUT_INFORMATION_MBR Mbr;
        DRIVE_LAYOUT_INFORMATION_GPT Gpt;
    } DUMMYUNIONNAME;
    PARTITION_INFORMATION_EX PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION_EX, *PDRIVE_LAYOUT_INFORMATION_EX;

#endif /* _WIN32_WINNT >= 0x0500 */

#if(_WIN32_WINNT >= 0x0500)

typedef enum _DETECTION_TYPE {
    DetectNone,
    DetectInt13,
    DetectExInt13
} DETECTION_TYPE;

typedef struct _DISK_INT13_INFO {
    WORD DriveSelect;
    DWORD MaxCylinders;
    WORD SectorsPerTrack;
    WORD MaxHeads;
    WORD NumberDrives;
} DISK_INT13_INFO, *PDISK_INT13_INFO;

typedef struct _DISK_EX_INT13_INFO {
    WORD ExBufferSize;
    WORD ExFlags;
    DWORD ExCylinders;
    DWORD ExHeads;
    DWORD ExSectorsPerTrack;
    DWORD64 ExSectorsPerDrive;
    WORD ExSectorSize;
    WORD ExReserved;
} DISK_EX_INT13_INFO, *PDISK_EX_INT13_INFO;


typedef struct _DISK_DETECTION_INFO {
    DWORD SizeOfDetectInfo;
    DETECTION_TYPE DetectionType;
    union {
        struct {
            DISK_INT13_INFO Int13;
            DISK_EX_INT13_INFO ExInt13;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} DISK_DETECTION_INFO, *PDISK_DETECTION_INFO;

typedef struct _DISK_PARTITION_INFO {
    DWORD SizeOfPartitionInfo;
    PARTITION_STYLE PartitionStyle;
    union {
        struct {
            DWORD Signature;
            DWORD CheckSum;
        } Mbr;
        struct {
            GUID DiskId;
        } Gpt;
    } DUMMYUNIONNAME;
} DISK_PARTITION_INFO, *PDISK_PARTITION_INFO;

#if (NTDDI_VERSION < NTDDI_WS03)
#define DiskGeometryGetPartition(Geometry)  ((PDISK_PARTITION_INFO)((Geometry)+1))
#define DiskGeometryGetDetect(Geometry)  ((PDISK_DETECTION_INFO)(((PBYTE)DiskGeometryGetPartition(Geometry) + DiskGeometryGetPartition(Geometry)->SizeOfPartitionInfo)))
#else /* NTDDI_VERSION >= NTDDI_WS03 */
#define DiskGeometryGetPartition(Geometry)  ((PDISK_PARTITION_INFO)((Geometry)->Data))
#define DiskGeometryGetDetect(Geometry)  ((PDISK_DETECTION_INFO)(((DWORD_PTR)DiskGeometryGetPartition(Geometry) + DiskGeometryGetPartition(Geometry)->SizeOfPartitionInfo)))
#endif /* NTDDI_VERSION >= NTDDI_WS03 */

typedef struct _DISK_GEOMETRY_EX {
    DISK_GEOMETRY Geometry;
    LARGE_INTEGER DiskSize;
    BYTE Data[1];
} DISK_GEOMETRY_EX, *PDISK_GEOMETRY_EX;

#endif /* _WIN32_WINNT > 0x0500 */

#if(_WIN32_WINNT >= 0x0400)
typedef struct _DISK_CONTROLLER_NUMBER {
    DWORD ControllerNumber;
    DWORD DiskNumber;
} DISK_CONTROLLER_NUMBER, *PDISK_CONTROLLER_NUMBER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)

typedef enum {
    EqualPriority,
    KeepPrefetchedData,
    KeepReadData
} DISK_CACHE_RETENTION_PRIORITY;

#if (OSVER(NTDDI_VERSION) == NTDDI_WINXP)
typedef enum _DISK_WRITE_CACHE_STATE {
    DiskWriteCacheNormal,
    DiskWriteCacheForceDisable,
    DiskWriteCacheDisableNotSupported
} DISK_WRITE_CACHE_STATE, *PDISK_WRITE_CACHE_STATE;
#endif /* OSVER(NTDDI_VERSION) == NTDDI_WINXP */

typedef struct _DISK_CACHE_INFORMATION {
    BOOLEAN ParametersSavable;
    BOOLEAN ReadCacheEnabled;
    BOOLEAN WriteCacheEnabled;
    DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority;
    DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority;
    WORD DisablePrefetchTransferLength;
    BOOLEAN PrefetchScalar;
    union {
        struct {
            WORD Minimum;
            WORD Maximum;
            WORD MaximumBlocks;
        } ScalarPrefetch;
        struct {
            WORD Minimum;
            WORD Maximum;
        } BlockPrefetch;
    } DUMMYUNIONNAME;
} DISK_CACHE_INFORMATION, *PDISK_CACHE_INFORMATION;

typedef struct _DISK_GROW_PARTITION {
    DWORD PartitionNumber;
    LARGE_INTEGER BytesToGrow;
} DISK_GROW_PARTITION, *PDISK_GROW_PARTITION;

#endif /* _WIN32_WINNT >= 0x0500 */

#define HIST_NO_OF_BUCKETS  24

typedef struct _HISTOGRAM_BUCKET {
    DWORD Reads;
    DWORD Writes;
} HISTOGRAM_BUCKET, *PHISTOGRAM_BUCKET;

#define HISTOGRAM_BUCKET_SIZE  sizeof(HISTOGRAM_BUCKET)

typedef struct _DISK_HISTOGRAM {
    LARGE_INTEGER DiskSize;
    LARGE_INTEGER Start;
    LARGE_INTEGER End;
    LARGE_INTEGER Average;
    LARGE_INTEGER AverageRead;
    LARGE_INTEGER AverageWrite;
    DWORD Granularity;
    DWORD Size;
    DWORD ReadCount;
    DWORD WriteCount;
    PHISTOGRAM_BUCKET Histogram;
} DISK_HISTOGRAM, *PDISK_HISTOGRAM;

#define DISK_HISTOGRAM_SIZE sizeof(DISK_HISTOGRAM)

typedef struct _DISK_PERFORMANCE {
    LARGE_INTEGER BytesRead;
    LARGE_INTEGER BytesWritten;
    LARGE_INTEGER ReadTime;
    LARGE_INTEGER WriteTime;
    LARGE_INTEGER IdleTime;
    DWORD ReadCount;
    DWORD WriteCount;
    DWORD QueueDepth;
    DWORD SplitCount;
    LARGE_INTEGER QueryTime;
    DWORD StorageDeviceNumber;
    WCHAR StorageManagerName[8];
} DISK_PERFORMANCE, *PDISK_PERFORMANCE;

typedef struct _DISK_RECORD {
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    PVOID VirtualAddress;
    DWORD NumberOfBytes;
    BYTE DeviceNumber;
    BOOLEAN ReadRequest;
} DISK_RECORD, *PDISK_RECORD;

typedef struct _DISK_LOGGING {
    BYTE Function;
    PVOID BufferAddress;
    DWORD BufferSize;
} DISK_LOGGING, *PDISK_LOGGING;

#define DISK_LOGGING_START  0
#define DISK_LOGGING_STOP  1
#define DISK_LOGGING_DUMP  2
#define DISK_BINNING  3

typedef enum _BIN_TYPES {
    RequestSize,
    RequestLocation
} BIN_TYPES;

typedef struct _BIN_RANGE {
    LARGE_INTEGER StartValue;
    LARGE_INTEGER Length;
} BIN_RANGE, *PBIN_RANGE;

typedef struct _PERF_BIN {
    DWORD NumberOfBins;
    DWORD TypeOfBin;
    BIN_RANGE BinsRanges[1];
} PERF_BIN, *PPERF_BIN;

typedef struct _BIN_COUNT {
    BIN_RANGE BinRange;
    DWORD BinCount;
} BIN_COUNT, *PBIN_COUNT;

typedef struct _BIN_RESULTS {
    DWORD NumberOfBins;
    BIN_COUNT BinCounts[1];
} BIN_RESULTS, *PBIN_RESULTS;

#if(_WIN32_WINNT >= 0x0400)

#include <pshpack1.h>
typedef struct _GETVERSIONINPARAMS {
    BYTE bVersion;
    BYTE bRevision;
    BYTE bReserved;
    BYTE bIDEDeviceMap;
    DWORD fCapabilities;
    DWORD dwReserved[4];
} GETVERSIONINPARAMS, *PGETVERSIONINPARAMS, *LPGETVERSIONINPARAMS;
#include <poppack.h>

#define CAP_ATA_ID_CMD  1
#define CAP_ATAPI_ID_CMD  2
#define CAP_SMART_CMD  4

#include <pshpack1.h>
typedef struct _IDEREGS {
    BYTE bFeaturesReg;
    BYTE bSectorCountReg;
    BYTE bSectorNumberReg;
    BYTE bCylLowReg;
    BYTE bCylHighReg;
    BYTE bDriveHeadReg;
    BYTE bCommandReg;
    BYTE bReserved;
} IDEREGS, *PIDEREGS, *LPIDEREGS;
#include <poppack.h>

#define ATAPI_ID_CMD  0xA1 
#define ID_CMD  0xEC
#define SMART_CMD  0xB0

#define SMART_CYL_LOW  0x4F
#define SMART_CYL_HI  0xC2

#include <pshpack1.h>
typedef struct _SENDCMDINPARAMS {
    DWORD cBufferSize;
    IDEREGS irDriveRegs;
    BYTE bDriveNumber;
    BYTE bReserved[3];
    DWORD dwReserved[4];
    BYTE bBuffer[1];
} SENDCMDINPARAMS, *PSENDCMDINPARAMS, *LPSENDCMDINPARAMS;
#include <poppack.h>

#include <pshpack1.h>
typedef struct _DRIVERSTATUS {
    BYTE bDriverError;
    BYTE bIDEError;
    BYTE bReserved[2];
    DWORD dwReserved[2];
} DRIVERSTATUS, *PDRIVERSTATUS, *LPDRIVERSTATUS;
#include <poppack.h>

#define SMART_NO_ERROR  0
#define SMART_IDE_ERROR  1
#define SMART_INVALID_FLAG  2
#define SMART_INVALID_COMMAND  3
#define SMART_INVALID_BUFFER  4
#define SMART_INVALID_DRIVE  5
#define SMART_INVALID_IOCTL  6
#define SMART_ERROR_NO_MEM  7
#define SMART_INVALID_REGISTER  8
#define SMART_NOT_SUPPORTED  9
#define SMART_NO_IDE_DEVICE  10

#define SMART_OFFLINE_ROUTINE_OFFLINE  0
#define SMART_SHORT_SELFTEST_OFFLINE  1
#define SMART_EXTENDED_SELFTEST_OFFLINE  2
#define SMART_ABORT_OFFLINE_SELFTEST  127
#define SMART_SHORT_SELFTEST_CAPTIVE  129
#define SMART_EXTENDED_SELFTEST_CAPTIVE  130

#include <pshpack1.h>
typedef struct _SENDCMDOUTPARAMS {
    DWORD cBufferSize;
    DRIVERSTATUS DriverStatus;
    BYTE bBuffer[1];
} SENDCMDOUTPARAMS, *PSENDCMDOUTPARAMS, *LPSENDCMDOUTPARAMS;
#include <poppack.h>

#define READ_ATTRIBUTE_BUFFER_SIZE  512
#define IDENTIFY_BUFFER_SIZE  512
#define READ_THRESHOLD_BUFFER_SIZE  512
#define SMART_LOG_SECTOR_SIZE  512

#define READ_ATTRIBUTES  0xD0
#define READ_THRESHOLDS  0xD1
#define ENABLE_DISABLE_AUTOSAVE 0xD2
#define SAVE_ATTRIBUTE_VALUES  0xD3
#define EXECUTE_OFFLINE_DIAGS  0xD4
#define SMART_READ_LOG  0xD5
#define SMART_WRITE_LOG  0xd6
#define ENABLE_SMART  0xD8
#define DISABLE_SMART  0xD9
#define RETURN_SMART_STATUS  0xDA
#define ENABLE_DISABLE_AUTO_OFFLINE 0xDB
#endif /* _WIN32_WINNT >= 0x0400 */

#define IOCTL_DISK_GET_DISK_ATTRIBUTES  CTL_CODE(IOCTL_DISK_BASE, 0x003c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_DISK_ATTRIBUTES  CTL_CODE(IOCTL_DISK_BASE, 0x003d, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define DISK_ATTRIBUTE_OFFLINE  0x0000000000000001
#define DISK_ATTRIBUTE_READ_ONLY  0x0000000000000002

typedef struct _GET_DISK_ATTRIBUTES {
    DWORD Version;
    DWORD Reserved1;
    DWORDLONG Attributes;
} GET_DISK_ATTRIBUTES, *PGET_DISK_ATTRIBUTES;

typedef struct _SET_DISK_ATTRIBUTES {
    DWORD Version;
    BOOLEAN Persist;
    BYTE Reserved1[3];
    DWORDLONG Attributes;
    DWORDLONG AttributesMask;
    DWORD Reserved2[4];
} SET_DISK_ATTRIBUTES, *PSET_DISK_ATTRIBUTES;

#define IOCTL_DISK_RESET_SNAPSHOT_INFO  CTL_CODE(IOCTL_DISK_BASE, 0x0084, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#endif /* _NTDDDISK_H */


#define IOCTL_CHANGER_BASE  FILE_DEVICE_CHANGER

#define IOCTL_CHANGER_GET_PARAMETERS  CTL_CODE(IOCTL_CHANGER_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_GET_STATUS  CTL_CODE(IOCTL_CHANGER_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_GET_PRODUCT_DATA  CTL_CODE(IOCTL_CHANGER_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_SET_ACCESS  CTL_CODE(IOCTL_CHANGER_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_CHANGER_GET_ELEMENT_STATUS  CTL_CODE(IOCTL_CHANGER_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS  CTL_CODE(IOCTL_CHANGER_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_SET_POSITION  CTL_CODE(IOCTL_CHANGER_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_EXCHANGE_MEDIUM  CTL_CODE(IOCTL_CHANGER_BASE, 0x0008, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_MOVE_MEDIUM  CTL_CODE(IOCTL_CHANGER_BASE, 0x0009, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_REINITIALIZE_TRANSPORT CTL_CODE(IOCTL_CHANGER_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_QUERY_VOLUME_TAGS  CTL_CODE(IOCTL_CHANGER_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define MAX_VOLUME_ID_SIZE  36
#define MAX_VOLUME_TEMPLATE_SIZE 40

#define VENDOR_ID_LENGTH  8
#define PRODUCT_ID_LENGTH  16
#define REVISION_LENGTH  4
#define SERIAL_NUMBER_LENGTH  32

typedef enum _ELEMENT_TYPE {
    AllElements,
    ChangerTransport,
    ChangerSlot,
    ChangerIEPort,
    ChangerDrive,
    ChangerDoor,
    ChangerKeypad,
    ChangerMaxElement
} ELEMENT_TYPE, *PELEMENT_TYPE;

typedef struct _CHANGER_ELEMENT {
    ELEMENT_TYPE ElementType;
    DWORD ElementAddress;
} CHANGER_ELEMENT, *PCHANGER_ELEMENT;

typedef struct _CHANGER_ELEMENT_LIST {
    CHANGER_ELEMENT Element;
    DWORD NumberOfElements;
} CHANGER_ELEMENT_LIST, *PCHANGER_ELEMENT_LIST;

#define CHANGER_BAR_CODE_SCANNER_INSTALLED  0x00000001
#define CHANGER_INIT_ELEM_STAT_WITH_RANGE  0x00000002
#define CHANGER_CLOSE_IEPORT  0x00000004
#define CHANGER_OPEN_IEPORT  0x00000008
#define CHANGER_STATUS_NON_VOLATILE  0x00000010
#define CHANGER_EXCHANGE_MEDIA  0x00000020
#define CHANGER_CLEANER_SLOT  0x00000040
#define CHANGER_LOCK_UNLOCK  0x00000080
#define CHANGER_CARTRIDGE_MAGAZINE  0x00000100
#define CHANGER_MEDIUM_FLIP  0x00000200
#define CHANGER_POSITION_TO_ELEMENT  0x00000400
#define CHANGER_REPORT_IEPORT_STATE  0x00000800
#define CHANGER_STORAGE_DRIVE  0x00001000
#define CHANGER_STORAGE_IEPORT  0x00002000
#define CHANGER_STORAGE_SLOT  0x00004000
#define CHANGER_STORAGE_TRANSPORT  0x00008000
#define CHANGER_DRIVE_CLEANING_REQUIRED  0x00010000
#define CHANGER_PREDISMOUNT_EJECT_REQUIRED  0x00020000
#define CHANGER_CLEANER_ACCESS_NOT_VALID  0x00040000
#define CHANGER_PREMOUNT_EJECT_REQUIRED  0x00080000
#define CHANGER_VOLUME_IDENTIFICATION  0x00100000
#define CHANGER_VOLUME_SEARCH  0x00200000
#define CHANGER_VOLUME_ASSERT  0x00400000
#define CHANGER_VOLUME_REPLACE  0x00800000
#define CHANGER_VOLUME_UNDEFINE  0x01000000
#define CHANGER_SERIAL_NUMBER_VALID  0x04000000
#define CHANGER_DEVICE_REINITIALIZE_CAPABLE 0x08000000
#define CHANGER_KEYPAD_ENABLE_DISABLE  0x10000000
#define CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS  0x20000000

#define CHANGER_RESERVED_BIT  0x80000000

#define CHANGER_PREDISMOUNT_ALIGN_TO_SLOT  0x80000001
#define CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE  0x80000002
#define CHANGER_CLEANER_AUTODISMOUNT  0x80000004
#define CHANGER_TRUE_EXCHANGE_CAPABLE  0x80000008
#define CHANGER_SLOTS_USE_TRAYS  0x80000010
#define CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR  0x80000020
#define CHANGER_CLEANER_OPS_NOT_SUPPORTED  0x80000040
#define CHANGER_IEPORT_USER_CONTROL_OPEN  0x80000080
#define CHANGER_IEPORT_USER_CONTROL_CLOSE  0x80000100
#define CHANGER_MOVE_EXTENDS_IEPORT  0x80000200
#define CHANGER_MOVE_RETRACTS_IEPORT  0x80000400

#define CHANGER_TO_TRANSPORT  0x01
#define CHANGER_TO_SLOT  0x02
#define CHANGER_TO_IEPORT  0x04
#define CHANGER_TO_DRIVE  0x08

#define LOCK_UNLOCK_IEPORT  0x01
#define LOCK_UNLOCK_DOOR  0x02
#define LOCK_UNLOCK_KEYPAD  0x04

typedef struct _GET_CHANGER_PARAMETERS {
    DWORD Size;
    WORD NumberTransportElements;
    WORD NumberStorageElements;
    WORD NumberCleanerSlots;
    WORD NumberIEElements;
    WORD NumberDataTransferElements;
    WORD NumberOfDoors;
    WORD FirstSlotNumber;
    WORD FirstDriveNumber;
    WORD FirstTransportNumber;
    WORD FirstIEPortNumber;
    WORD FirstCleanerSlotAddress;
    WORD MagazineSize;
    DWORD DriveCleanTimeout;
    DWORD Features0;
    DWORD Features1;
    BYTE MoveFromTransport;
    BYTE MoveFromSlot;
    BYTE MoveFromIePort;
    BYTE MoveFromDrive;
    BYTE ExchangeFromTransport;
    BYTE ExchangeFromSlot;
    BYTE ExchangeFromIePort;
    BYTE ExchangeFromDrive;
    BYTE LockUnlockCapabilities;
    BYTE PositionCapabilities;
    BYTE Reserved1[2];
    DWORD Reserved2[2];
} GET_CHANGER_PARAMETERS, *PGET_CHANGER_PARAMETERS;

typedef struct _CHANGER_PRODUCT_DATA {
    BYTE VendorId[VENDOR_ID_LENGTH];
    BYTE ProductId[PRODUCT_ID_LENGTH];
    BYTE Revision[REVISION_LENGTH];
    BYTE SerialNumber[SERIAL_NUMBER_LENGTH];
    BYTE DeviceType;
} CHANGER_PRODUCT_DATA, *PCHANGER_PRODUCT_DATA;

#define LOCK_ELEMENT  0
#define UNLOCK_ELEMENT  1
#define EXTEND_IEPORT  2
#define RETRACT_IEPORT  3

typedef struct _CHANGER_SET_ACCESS {
    CHANGER_ELEMENT Element;
    DWORD Control;
} CHANGER_SET_ACCESS, *PCHANGER_SET_ACCESS;

typedef struct _CHANGER_READ_ELEMENT_STATUS {
    CHANGER_ELEMENT_LIST ElementList;
    BOOLEAN VolumeTagInfo;
} CHANGER_READ_ELEMENT_STATUS, *PCHANGER_READ_ELEMENT_STATUS;

typedef struct _CHANGER_ELEMENT_STATUS {
    CHANGER_ELEMENT Element;
    CHANGER_ELEMENT SrcElementAddress;
    DWORD Flags;
    DWORD ExceptionCode;
    BYTE TargetId;
    BYTE Lun;
    WORD Reserved;
    BYTE PrimaryVolumeID[MAX_VOLUME_ID_SIZE];
    BYTE AlternateVolumeID[MAX_VOLUME_ID_SIZE];
} CHANGER_ELEMENT_STATUS, *PCHANGER_ELEMENT_STATUS;

typedef struct _CHANGER_ELEMENT_STATUS_EX {
    CHANGER_ELEMENT Element;
    CHANGER_ELEMENT SrcElementAddress;
    DWORD Flags;
    DWORD ExceptionCode;
    BYTE TargetId;
    BYTE Lun;
    WORD Reserved;
    BYTE PrimaryVolumeID[MAX_VOLUME_ID_SIZE];
    BYTE AlternateVolumeID[MAX_VOLUME_ID_SIZE];
    BYTE VendorIdentification[VENDOR_ID_LENGTH];
    BYTE ProductIdentification[PRODUCT_ID_LENGTH];
    BYTE SerialNumber[SERIAL_NUMBER_LENGTH];
} CHANGER_ELEMENT_STATUS_EX, *PCHANGER_ELEMENT_STATUS_EX;

#define ELEMENT_STATUS_FULL  0x00000001
#define ELEMENT_STATUS_IMPEXP  0x00000002
#define ELEMENT_STATUS_EXCEPT  0x00000004
#define ELEMENT_STATUS_ACCESS  0x00000008
#define ELEMENT_STATUS_EXENAB  0x00000010
#define ELEMENT_STATUS_INENAB  0x00000020

#define ELEMENT_STATUS_PRODUCT_DATA 0x00000040

#define ELEMENT_STATUS_LUN_VALID 0x00001000
#define ELEMENT_STATUS_ID_VALID  0x00002000
#define ELEMENT_STATUS_NOT_BUS  0x00008000
#define ELEMENT_STATUS_INVERT  0x00400000
#define ELEMENT_STATUS_SVALID  0x00800000

#define ELEMENT_STATUS_PVOLTAG  0x10000000
#define ELEMENT_STATUS_AVOLTAG  0x20000000

#define ERROR_LABEL_UNREADABLE  0x00000001
#define ERROR_LABEL_QUESTIONABLE  0x00000002
#define ERROR_SLOT_NOT_PRESENT  0x00000004
#define ERROR_DRIVE_NOT_INSTALLED 0x00000008
#define ERROR_TRAY_MALFUNCTION  0x00000010
#define ERROR_INIT_STATUS_NEEDED  0x00000011
#define ERROR_UNHANDLED_ERROR  0xFFFFFFFF

typedef struct _CHANGER_INITIALIZE_ELEMENT_STATUS {
    CHANGER_ELEMENT_LIST ElementList;
    BOOLEAN BarCodeScan;
} CHANGER_INITIALIZE_ELEMENT_STATUS, *PCHANGER_INITIALIZE_ELEMENT_STATUS;

typedef struct _CHANGER_SET_POSITION {
    CHANGER_ELEMENT Transport;
    CHANGER_ELEMENT Destination;
    BOOLEAN Flip;
} CHANGER_SET_POSITION, *PCHANGER_SET_POSITION;

typedef struct _CHANGER_EXCHANGE_MEDIUM {
    CHANGER_ELEMENT Transport;
    CHANGER_ELEMENT Source;
    CHANGER_ELEMENT Destination1;
    CHANGER_ELEMENT Destination2;
    BOOLEAN Flip1;
    BOOLEAN Flip2;
} CHANGER_EXCHANGE_MEDIUM, *PCHANGER_EXCHANGE_MEDIUM;

typedef struct _CHANGER_MOVE_MEDIUM {
    CHANGER_ELEMENT Transport;
    CHANGER_ELEMENT Source;
    CHANGER_ELEMENT Destination;
    BOOLEAN Flip;
} CHANGER_MOVE_MEDIUM, *PCHANGER_MOVE_MEDIUM;

typedef struct _CHANGER_SEND_VOLUME_TAG_INFORMATION {
    CHANGER_ELEMENT StartingElement;
    DWORD ActionCode;
    BYTE VolumeIDTemplate[MAX_VOLUME_TEMPLATE_SIZE];
} CHANGER_SEND_VOLUME_TAG_INFORMATION, *PCHANGER_SEND_VOLUME_TAG_INFORMATION;

typedef struct _READ_ELEMENT_ADDRESS_INFO {
    DWORD NumberOfElements;
    CHANGER_ELEMENT_STATUS ElementStatus[1];
} READ_ELEMENT_ADDRESS_INFO, *PREAD_ELEMENT_ADDRESS_INFO;

#define SEARCH_ALL  0x0
#define SEARCH_PRIMARY  0x1
#define SEARCH_ALTERNATE  0x2
#define SEARCH_ALL_NO_SEQ  0x4
#define SEARCH_PRI_NO_SEQ  0x5
#define SEARCH_ALT_NO_SEQ  0x6

#define ASSERT_PRIMARY  0x8
#define ASSERT_ALTERNATE  0x9

#define REPLACE_PRIMARY  0xA
#define REPLACE_ALTERNATE  0xB

#define UNDEFINE_PRIMARY  0xC
#define UNDEFINE_ALTERNATE 0xD

typedef enum _CHANGER_DEVICE_PROBLEM_TYPE {
    DeviceProblemNone,
    DeviceProblemHardware,
    DeviceProblemCHMError,
    DeviceProblemDoorOpen,
    DeviceProblemCalibrationError,
    DeviceProblemTargetFailure,
    DeviceProblemCHMMoveError,
    DeviceProblemCHMZeroError,
    DeviceProblemCartridgeInsertError,
    DeviceProblemPositionError,
    DeviceProblemSensorError,
    DeviceProblemCartridgeEjectError,
    DeviceProblemGripperError,
    DeviceProblemDriveError
} CHANGER_DEVICE_PROBLEM_TYPE, *PCHANGER_DEVICE_PROBLEM_TYPE;

#define IOCTL_SERIAL_LSRMST_INSERT  CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_SERENUM_EXPOSE_HARDWARE  CTL_CODE(FILE_DEVICE_SERENUM,128,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_REMOVE_HARDWARE  CTL_CODE(FILE_DEVICE_SERENUM,129,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_PORT_DESC  CTL_CODE(FILE_DEVICE_SERENUM,130,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_GET_PORT_NAME  CTL_CODE(FILE_DEVICE_SERENUM,131,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define SERIAL_LSRMST_ESCAPE  ((BYTE )0x00)
#define SERIAL_LSRMST_LSR_DATA  ((BYTE )0x01)
#define SERIAL_LSRMST_LSR_NODATA ((BYTE )0x02)
#define SERIAL_LSRMST_MST  ((BYTE )0x03)

#define SERIAL_IOC_FCR_FIFO_ENABLE  ((DWORD)0x00000001)
#define SERIAL_IOC_FCR_RCVR_RESET  ((DWORD)0x00000002)
#define SERIAL_IOC_FCR_XMIT_RESET  ((DWORD)0x00000004)
#define SERIAL_IOC_FCR_DMA_MODE  ((DWORD)0x00000008)
#define SERIAL_IOC_FCR_RES1  ((DWORD)0x00000010)
#define SERIAL_IOC_FCR_RES2  ((DWORD)0x00000020)
#define SERIAL_IOC_FCR_RCVR_TRIGGER_LSB ((DWORD)0x00000040)
#define SERIAL_IOC_FCR_RCVR_TRIGGER_MSB ((DWORD)0x00000080)

#define SERIAL_IOC_MCR_DTR  ((DWORD)0x00000001)
#define SERIAL_IOC_MCR_RTS  ((DWORD)0x00000002)
#define SERIAL_IOC_MCR_OUT1  ((DWORD)0x00000004)
#define SERIAL_IOC_MCR_OUT2  ((DWORD)0x00000008)
#define SERIAL_IOC_MCR_LOOP  ((DWORD)0x00000010)


#ifndef _FILESYSTEMFSCTL_
#define _FILESYSTEMFSCTL_

#define FSCTL_REQUEST_OPLOCK_LEVEL_1  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_OPLOCK_LEVEL_2  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_BATCH_OPLOCK  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_ACKNOWLEDGE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPBATCH_ACK_CLOSE_PENDING CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OPLOCK_BREAK_NOTIFY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_LOCK_VOLUME  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_UNLOCK_VOLUME  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DISMOUNT_VOLUME  CTL_CODE(FILE_DEVICE_FILE_SYSTEM,  8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_VOLUME_MOUNTED  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_PATHNAME_VALID  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MARK_VOLUME_DIRTY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_RETRIEVAL_POINTERS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 14,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_GET_COMPRESSION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_COMPRESSION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 16, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_SET_BOOTLOADER_ACCESSED  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 19,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_MARK_AS_SYSTEM_HIVE  FSCTL_SET_BOOTLOADER_ACCESSED
#define FSCTL_OPLOCK_BREAK_ACK_NO_2  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_INVALIDATE_VOLUMES  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_FAT_BPB  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 22, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REQUEST_FILTER_OPLOCK  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 23, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILESYSTEM_GET_STATISTICS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 24, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if (_WIN32_WINNT >= _WIN32_WINNT_NT4)
#define FSCTL_GET_NTFS_VOLUME_DATA  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 25, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_NTFS_FILE_RECORD  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 26, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_VOLUME_BITMAP  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 27,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_GET_RETRIEVAL_POINTERS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 28,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_MOVE_FILE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 29, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_IS_VOLUME_DIRTY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 30, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_ALLOW_EXTENDED_DASD_IO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 32, METHOD_NEITHER,  FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_NT4 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
#define FSCTL_FIND_FILES_BY_SID  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 35, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_SET_OBJECT_ID  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 38, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_GET_OBJECT_ID  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 39, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_OBJECT_ID  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 40, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPARSE_POINT  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 41, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_GET_REPARSE_POINT  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 42, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_REPARSE_POINT  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 43, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_ENUM_USN_DATA  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 44,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_SECURITY_ID_CHECK  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 45,  METHOD_NEITHER, FILE_READ_DATA)
#define FSCTL_READ_USN_JOURNAL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 46,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_SET_OBJECT_ID_EXTENDED  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 47, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_CREATE_OR_GET_OBJECT_ID  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 48, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_SPARSE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 49, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_ZERO_DATA  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 50, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_QUERY_ALLOCATED_RANGES  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 51,  METHOD_NEITHER, FILE_READ_DATA)
#define FSCTL_ENABLE_UPGRADE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 52, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_SET_ENCRYPTION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 53,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_ENCRYPTION_FSCTL_IO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 54,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_WRITE_RAW_ENCRYPTED  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 55,  METHOD_NEITHER, FILE_SPECIAL_ACCESS)
#define FSCTL_READ_RAW_ENCRYPTED  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 56,  METHOD_NEITHER, FILE_SPECIAL_ACCESS)
#define FSCTL_CREATE_USN_JOURNAL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 57,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_READ_FILE_USN_DATA  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 58,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_WRITE_USN_CLOSE_RECORD  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 59,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_EXTEND_VOLUME  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 60, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_USN_JOURNAL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 61, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_USN_JOURNAL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 62, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_MARK_HANDLE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 63, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_COPYFILE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 64, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SIS_LINK_FILES  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 65, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_RECALL_FILE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 69, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_READ_FROM_PLEX  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 71, METHOD_OUT_DIRECT, FILE_READ_DATA)
#define FSCTL_FILE_PREFETCH  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 72, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
#define FSCTL_MAKE_MEDIA_COMPATIBLE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 76, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_SET_DEFECT_MANAGEMENT  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 77, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_QUERY_SPARING_INFO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 78, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_ON_DISK_VOLUME_INFO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 79, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_VOLUME_COMPRESSION_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 80, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_TXFS_MODIFY_RM  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 81, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_QUERY_RM_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 82, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_ROLLFORWARD_REDO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 84, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_ROLLFORWARD_UNDO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 85, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_START_RM  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 86, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_SHUTDOWN_RM  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 87, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_READ_BACKUP_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 88, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 89, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_CREATE_SECONDARY_RM  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 90, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_GET_METADATA_INFO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 91, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_GET_TRANSACTED_VERSION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 92, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_SAVEPOINT_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 94, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_CREATE_MINIVERSION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 95, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_TXFS_TRANSACTION_ACTIVE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 99, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_SET_ZERO_ON_DEALLOCATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 101, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_REPAIR  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_REPAIR  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_WAIT_FOR_REPAIR  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 104, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_INITIATE_REPAIR  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSC_INTERNAL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 107, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_SHRINK_VOLUME  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 108, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_SET_SHORT_NAME_BEHAVIOR  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DFSR_SET_GHOST_HANDLE_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 110, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_TXFS_LIST_TRANSACTION_LOCKED_FILES  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 120, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_TXFS_LIST_TRANSACTIONS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 121, METHOD_BUFFERED, FILE_READ_DATA)
#define FSCTL_QUERY_PAGEFILE_ENCRYPTION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 122, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_VISTA */

#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
#define FSCTL_RESET_VOLUME_ALLOCATION_HINTS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 123, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_VISTA */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FSCTL_QUERY_DEPENDENT_VOLUME  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 124, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SD_GLOBAL_CHANGE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 125, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)
#define FSCTL_TXFS_READ_BACKUP_INFORMATION2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 126, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_VISTA */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FSCTL_LOOKUP_STREAM_FROM_CLUSTER  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 127, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_TXFS_WRITE_BACKUP_INFORMATION2 CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 128, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILE_TYPE_NOTIFICATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 129, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
#define FSCTL_FILE_LEVEL_TRIM  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 130, METHOD_BUFFERED, FILE_WRITE_DATA)
#endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FSCTL_GET_BOOT_AREA_INFO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 140, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_RETRIEVAL_POINTER_BASE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 141, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_PERSISTENT_VOLUME_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 142, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_PERSISTENT_VOLUME_STATE CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 143, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_REQUEST_OPLOCK  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 144, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_CSV_TUNNEL_REQUEST  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 145, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_CSV_FILE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 146, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_QUERY_FILE_SYSTEM_RECOGNITION CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 147, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_PATH_NAME  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 148, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_NAME_FOR_VOLUME_MOUNT_POINT CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 149, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_GET_VOLUME_PATH_NAMES_FOR_VOLUME_NAME CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 150,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_IS_FILE_ON_CSV_VOLUME  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 151,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
#define FSCTL_CORRUPTION_HANDLING  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 152, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_OFFLOAD_READ  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 153, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FSCTL_OFFLOAD_WRITE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 154, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FSCTL_CSV_INTERNAL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 155,  METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
#define FSCTL_SET_PURGE_FAILURE_MODE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 156, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_FILE_LAYOUT  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 157, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_IS_VOLUME_OWNED_BYCSVFS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 158,  METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_GET_INTEGRITY_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 159, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_INTEGRITY_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 160, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)

#define FSCTL_QUERY_FILE_REGIONS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 161, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
#define FSCTL_DEDUP_FILE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 165, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DEDUP_QUERY_FILE_HASHES  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 166, METHOD_NEITHER, FILE_READ_DATA)
#define FSCTL_DEDUP_QUERY_RANGE_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 167, METHOD_NEITHER, FILE_READ_DATA)
#define FSCTL_DEDUP_QUERY_REPARSE_INFO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 168, METHOD_NEITHER, FILE_ANY_ACCESS)
#endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
#define FSCTL_RKF_INTERNAL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 171, METHOD_NEITHER, FILE_ANY_ACCESS)

#define FSCTL_SCRUB_DATA  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 172, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_REPAIR_COPIES  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 173, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define FSCTL_DISABLE_LOCAL_BUFFERING  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 174, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_MGMT_LOCK  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 175, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_QUERY_DOWN_LEVEL_FILE_SYSTEM_CHARACTERISTICS CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 176, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_ADVANCE_FILE_ID  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 177, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_SYNC_TUNNEL_REQUEST  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 178, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_QUERY_VETO_FILE_DIRECT_IO CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 179, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_WRITE_USN_REASON  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 180, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_CONTROL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 181, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_GET_REFS_VOLUME_DATA  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 182, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_CSV_H_BREAKING_SYNC_TUNNEL_REQUEST CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 185, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
#define FSCTL_QUERY_STORAGE_CLASSES  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 187, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_REGION_INFO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 188, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_USN_TRACK_MODIFIED_RANGES  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 189, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINBLUE */
#if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
#define FSCTL_QUERY_SHARED_VIRTUAL_DISK_SUPPORT CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 192, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SVHDX_SYNC_TUNNEL_REQUEST  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 193, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SVHDX_SET_INITIATOR_INFORMATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 194, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINBLUE */
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FSCTL_SET_EXTERNAL_BACKING  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 195, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_GET_EXTERNAL_BACKING  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 196, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_DELETE_EXTERNAL_BACKING  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 197, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_ENUM_EXTERNAL_BACKING  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 198, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_ENUM_OVERLAY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 199, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_ADD_OVERLAY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 204, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_REMOVE_OVERLAY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 205, METHOD_BUFFERED, FILE_WRITE_DATA)
#define FSCTL_UPDATE_OVERLAY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 206, METHOD_BUFFERED, FILE_WRITE_DATA)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */
#if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
#define FSCTL_DUPLICATE_EXTENTS_TO_FILE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 209, METHOD_BUFFERED, FILE_WRITE_DATA )
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINBLUE */
#if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
#define FSCTL_SPARSE_OVERALLOCATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 211, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_STORAGE_QOS_CONTROL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 212, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINBLUE */
#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
#define FSCTL_INITIATE_FILE_METADATA_OPTIMIZATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 215, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define FSCTL_QUERY_FILE_METADATA_OPTIMIZATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 216, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */
#if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
#define FSCTL_SVHDX_ASYNC_TUNNEL_REQUEST  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 217, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINBLUE */
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FSCTL_GET_WOF_VERSION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 218, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
#define FSCTL_HCS_SYNC_TUNNEL_REQUEST  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 219, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_HCS_ASYNC_TUNNEL_REQUEST  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 220, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_EXTENT_READ_CACHE_INFO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 221, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_QUERY_REFS_VOLUME_COUNTER_INFO  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 222, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_CLEAN_VOLUME_METADATA  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 223, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_INTEGRITY_INFORMATION_EX  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 224, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define FSCTL_SUSPEND_OVERLAY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 225, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif
#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
#define FSCTL_VIRTUAL_STORAGE_QUERY_PROPERTY  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 226, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_FILESYSTEM_GET_STATISTICS_EX  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 227, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_QUERY_VOLUME_CONTAINER_STATE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 228, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SET_LAYER_ROOT  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 229, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN10_TH2)
#define FSCTL_QUERY_DIRECT_ACCESS_EXTENTS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 230, METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_NOTIFY_STORAGE_SPACE_ALLOCATION  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 231, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_SSDI_STORAGE_REQUEST  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 232, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN10_RS1)
#define FSCTL_QUERY_DIRECT_IMAGE_ORIGINAL_BASE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 233, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FSCTL_READ_UNPRIVILEGED_USN_JOURNAL  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 234,  METHOD_NEITHER, FILE_ANY_ACCESS)
#define FSCTL_START_VIRTUALIZATION_INSTANCE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 235, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN10_TH2)
#define FSCTL_GHOST_FILE_EXTENTS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 235, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define FSCTL_QUERY_GHOSTED_FILE_EXTENTS  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 236, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN10_TH2)
#define FSCTL_UNMAP_SPACE  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 237, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif
#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
#define FSCTL_HCS_SYNC_NO_WRITE_TUNNEL_REQUEST  CTL_CODE(FILE_DEVICE_FILE_SYSTEM, 238, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#define IOCTL_AVIO_ALLOCATE_STREAM  CTL_CODE(FILE_DEVICE_AVIO, 1, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_AVIO_FREE_STREAM  CTL_CODE(FILE_DEVICE_AVIO, 2, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)
#define IOCTL_AVIO_MODIFY_STREAM  CTL_CODE(FILE_DEVICE_AVIO, 3, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _PATHNAME_BUFFER {
    DWORD PathNameLength;
    WCHAR Name[1];
} PATHNAME_BUFFER, *PPATHNAME_BUFFER;

typedef struct _FSCTL_QUERY_FAT_BPB_BUFFER {
    BYTE First0x24BytesOfBootSector[0x24];
} FSCTL_QUERY_FAT_BPB_BUFFER, *PFSCTL_QUERY_FAT_BPB_BUFFER;

#if (_WIN32_WINNT >= _WIN32_WINNT_NT4)

typedef struct {
    LARGE_INTEGER VolumeSerialNumber;
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER TotalClusters;
    LARGE_INTEGER FreeClusters;
    LARGE_INTEGER TotalReserved;
    DWORD BytesPerSector;
    DWORD BytesPerCluster;
    DWORD BytesPerFileRecordSegment;
    DWORD ClustersPerFileRecordSegment;
    LARGE_INTEGER MftValidDataLength;
    LARGE_INTEGER MftStartLcn;
    LARGE_INTEGER Mft2StartLcn;
    LARGE_INTEGER MftZoneStart;
    LARGE_INTEGER MftZoneEnd;
} NTFS_VOLUME_DATA_BUFFER, *PNTFS_VOLUME_DATA_BUFFER;

typedef struct {
    DWORD ByteCount;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORD BytesPerPhysicalSector;
    WORD LfsMajorVersion;
    WORD LfsMinorVersion;
#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
    DWORD MaxDeviceTrimExtentCount;
    DWORD MaxDeviceTrimByteCount;
    DWORD MaxVolumeTrimExtentCount;
    DWORD MaxVolumeTrimByteCount;
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */
} NTFS_EXTENDED_VOLUME_DATA, *PNTFS_EXTENDED_VOLUME_DATA;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_NT4 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

typedef struct {
    DWORD ByteCount;
    DWORD MajorVersion;
    DWORD MinorVersion;
    DWORD BytesPerPhysicalSector;
    LARGE_INTEGER VolumeSerialNumber;
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER TotalClusters;
    LARGE_INTEGER FreeClusters;
    LARGE_INTEGER TotalReserved;
    DWORD BytesPerSector;
    DWORD BytesPerCluster;
    LARGE_INTEGER MaximumSizeOfResidentFile;
    LARGE_INTEGER Reserved[10];
} REFS_VOLUME_DATA_BUFFER, *PREFS_VOLUME_DATA_BUFFER;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN8 */


#if (_WIN32_WINNT >= _WIN32_WINNT_NT4)

typedef struct {
    LARGE_INTEGER StartingLcn;
} STARTING_LCN_INPUT_BUFFER, *PSTARTING_LCN_INPUT_BUFFER;

#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)

#define GET_VOLUME_BITMAP_FLAG_MASK_METADATA  0x00000001

typedef struct {
    LARGE_INTEGER StartingLcn;
    DWORD Flags;
} STARTING_LCN_INPUT_BUFFER_EX, *PSTARTING_LCN_INPUT_BUFFER_EX;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */

typedef struct {
    LARGE_INTEGER StartingLcn;
    LARGE_INTEGER BitmapSize;
    BYTE Buffer[1];
} VOLUME_BITMAP_BUFFER, *PVOLUME_BITMAP_BUFFER;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_NT4 */

#if (_WIN32_WINNT >= _WIN32_WINNT_NT4)

typedef struct {
    LARGE_INTEGER StartingVcn;
} STARTING_VCN_INPUT_BUFFER, *PSTARTING_VCN_INPUT_BUFFER;

typedef struct RETRIEVAL_POINTERS_BUFFER {
    DWORD ExtentCount;
    LARGE_INTEGER StartingVcn;
    struct {
        LARGE_INTEGER NextVcn;
        LARGE_INTEGER Lcn;
    } Extents[1];
} RETRIEVAL_POINTERS_BUFFER, *PRETRIEVAL_POINTERS_BUFFER;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_NT4 */

#if (_WIN32_WINNT >= _WIN32_WINNT_NT4)

typedef struct {
    LARGE_INTEGER FileReferenceNumber;
} NTFS_FILE_RECORD_INPUT_BUFFER, *PNTFS_FILE_RECORD_INPUT_BUFFER;

typedef struct {
    LARGE_INTEGER FileReferenceNumber;
    DWORD FileRecordLength;
    BYTE FileRecordBuffer[1];
} NTFS_FILE_RECORD_OUTPUT_BUFFER, *PNTFS_FILE_RECORD_OUTPUT_BUFFER;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_NT4 */

#if (_WIN32_WINNT >= _WIN32_WINNT_NT4)

typedef struct {
    HANDLE FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    DWORD ClusterCount;
} MOVE_FILE_DATA, *PMOVE_FILE_DATA;

typedef struct {
    HANDLE FileHandle;
    LARGE_INTEGER SourceFileRecord;
    LARGE_INTEGER TargetFileRecord;
} MOVE_FILE_RECORD_DATA, *PMOVE_FILE_RECORD_DATA;

#ifdef _WIN64
typedef struct _MOVE_FILE_DATA32 {
    UINT32 FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    DWORD ClusterCount;
} MOVE_FILE_DATA32, *PMOVE_FILE_DATA32;
#endif /* _WIN64 */

#endif /* _WIN32_WINNT >= _WIN32_WINNT_NT4 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)

typedef struct {
    DWORD Restart;
    SID Sid;
} FIND_BY_SID_DATA, *PFIND_BY_SID_DATA;

typedef struct {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FIND_BY_SID_OUTPUT, *PFIND_BY_SID_OUTPUT;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)

typedef struct {
    DWORDLONG StartFileReferenceNumber;
    USN LowUsn;
    USN HighUsn;
} MFT_ENUM_DATA_V0, *PMFT_ENUM_DATA_V0;

typedef struct {
    DWORDLONG StartFileReferenceNumber;
    USN LowUsn;
    USN HighUsn;
    WORD MinMajorVersion;
    WORD MaxMajorVersion;
} MFT_ENUM_DATA_V1, *PMFT_ENUM_DATA_V1;

#if (NTDDI_VERSION >= NTDDI_WIN8)
typedef MFT_ENUM_DATA_V1 MFT_ENUM_DATA, *PMFT_ENUM_DATA;
#else /* NTDDI_VERSION < NTDDI_WIN8 */
typedef MFT_ENUM_DATA_V0 MFT_ENUM_DATA, *PMFT_ENUM_DATA;
#endif /* NTDDI_VERSION < NTDDI_WIN8 */

typedef struct {
    DWORDLONG MaximumSize;
    DWORDLONG AllocationDelta;
} CREATE_USN_JOURNAL_DATA, *PCREATE_USN_JOURNAL_DATA;

typedef struct {
    WORD MinMajorVersion;
    WORD MaxMajorVersion;
} READ_FILE_USN_DATA, *PREAD_FILE_USN_DATA;

typedef struct {
    USN StartUsn;
    DWORD ReasonMask;
    DWORD ReturnOnlyOnClose;
    DWORDLONG Timeout;
    DWORDLONG BytesToWaitFor;
    DWORDLONG UsnJournalID;
} READ_USN_JOURNAL_DATA_V0, *PREAD_USN_JOURNAL_DATA_V0;

typedef struct {
    USN StartUsn;
    DWORD ReasonMask;
    DWORD ReturnOnlyOnClose;
    DWORDLONG Timeout;
    DWORDLONG BytesToWaitFor;
    DWORDLONG UsnJournalID;
    WORD MinMajorVersion;
    WORD MaxMajorVersion;
} READ_USN_JOURNAL_DATA_V1, *PREAD_USN_JOURNAL_DATA_V1;

#if (NTDDI_VERSION >= NTDDI_WIN8)
typedef READ_USN_JOURNAL_DATA_V1 READ_USN_JOURNAL_DATA, *PREAD_USN_JOURNAL_DATA;
#else /* NTDDI_VERSION < NTDDI_WIN8 */
typedef READ_USN_JOURNAL_DATA_V0 READ_USN_JOURNAL_DATA, *PREAD_USN_JOURNAL_DATA;
#endif /* NTDDI_VERSION < NTDDI_WIN8 */

typedef struct {
    DWORD Flags;
    DWORD Unused;
    DWORDLONG ChunkSize;
    LONGLONG FileSizeThreshold;
} USN_TRACK_MODIFIED_RANGES, *PUSN_TRACK_MODIFIED_RANGES;

typedef struct {
    USN Usn;
} USN_RANGE_TRACK_OUTPUT, *PUSN_RANGE_TRACK_OUTPUT;

#define FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE 0x00000001

typedef struct {
    DWORD RecordLength;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORDLONG FileReferenceNumber;
    DWORDLONG ParentFileReferenceNumber;
    USN Usn;
    LARGE_INTEGER TimeStamp;
    DWORD Reason;
    DWORD SourceInfo;
    DWORD SecurityId;
    DWORD FileAttributes;
    WORD FileNameLength;
    WORD FileNameOffset;
    WCHAR FileName[1];
} USN_RECORD_V2, *PUSN_RECORD_V2;

typedef struct {
    DWORD RecordLength;
    WORD MajorVersion;
    WORD MinorVersion;
    FILE_ID_128 FileReferenceNumber;
    FILE_ID_128 ParentFileReferenceNumber;
    USN Usn;
    LARGE_INTEGER TimeStamp;
    DWORD Reason;
    DWORD SourceInfo;
    DWORD SecurityId;
    DWORD FileAttributes;
    WORD FileNameLength;
    WORD FileNameOffset;
    WCHAR FileName[1];
} USN_RECORD_V3, *PUSN_RECORD_V3;

typedef USN_RECORD_V2 USN_RECORD, *PUSN_RECORD;

typedef struct {
    DWORD RecordLength;
    WORD MajorVersion;
    WORD MinorVersion;
} USN_RECORD_COMMON_HEADER, *PUSN_RECORD_COMMON_HEADER;

typedef struct {
    LONGLONG Offset;
    LONGLONG Length;
} USN_RECORD_EXTENT, *PUSN_RECORD_EXTENT;

typedef struct {
    USN_RECORD_COMMON_HEADER Header;
    FILE_ID_128 FileReferenceNumber;
    FILE_ID_128 ParentFileReferenceNumber;
    USN Usn;
    DWORD Reason;
    DWORD SourceInfo;
    DWORD RemainingExtents;
    WORD NumberOfExtents;
    WORD ExtentSize;
    USN_RECORD_EXTENT Extents[1];
} USN_RECORD_V4, *PUSN_RECORD_V4;

typedef union {
    USN_RECORD_COMMON_HEADER Header;
    USN_RECORD_V2 V2;
    USN_RECORD_V3 V3;
    USN_RECORD_V4 V4;
} USN_RECORD_UNION, *PUSN_RECORD_UNION;

#define USN_PAGE_SIZE  (0x1000)

#define USN_REASON_DATA_OVERWRITE  (0x00000001)
#define USN_REASON_DATA_EXTEND  (0x00000002)
#define USN_REASON_DATA_TRUNCATION  (0x00000004)
#define USN_REASON_NAMED_DATA_OVERWRITE  (0x00000010)
#define USN_REASON_NAMED_DATA_EXTEND  (0x00000020)
#define USN_REASON_NAMED_DATA_TRUNCATION (0x00000040)
#define USN_REASON_FILE_CREATE  (0x00000100)
#define USN_REASON_FILE_DELETE  (0x00000200)
#define USN_REASON_EA_CHANGE  (0x00000400)
#define USN_REASON_SECURITY_CHANGE  (0x00000800)
#define USN_REASON_RENAME_OLD_NAME  (0x00001000)
#define USN_REASON_RENAME_NEW_NAME  (0x00002000)
#define USN_REASON_INDEXABLE_CHANGE  (0x00004000)
#define USN_REASON_BASIC_INFO_CHANGE  (0x00008000)
#define USN_REASON_HARD_LINK_CHANGE  (0x00010000)
#define USN_REASON_COMPRESSION_CHANGE  (0x00020000)
#define USN_REASON_ENCRYPTION_CHANGE  (0x00040000)
#define USN_REASON_OBJECT_ID_CHANGE  (0x00080000)
#define USN_REASON_REPARSE_POINT_CHANGE  (0x00100000)
#define USN_REASON_STREAM_CHANGE  (0x00200000)
#define USN_REASON_TRANSACTED_CHANGE  (0x00400000)
#define USN_REASON_INTEGRITY_CHANGE  (0x00800000)
#define USN_REASON_CLOSE  (0x80000000)

typedef struct {
    DWORDLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    DWORDLONG MaximumSize;
    DWORDLONG AllocationDelta;
} USN_JOURNAL_DATA_V0, *PUSN_JOURNAL_DATA_V0;

typedef struct {
    DWORDLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    DWORDLONG MaximumSize;
    DWORDLONG AllocationDelta;
    WORD MinSupportedMajorVersion;
    WORD MaxSupportedMajorVersion;
} USN_JOURNAL_DATA_V1, *PUSN_JOURNAL_DATA_V1;

typedef struct {
    DWORDLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    DWORDLONG MaximumSize;
    DWORDLONG AllocationDelta;
    WORD MinSupportedMajorVersion;
    WORD MaxSupportedMajorVersion;
    DWORD Flags;
    DWORDLONG RangeTrackChunkSize;
    LONGLONG RangeTrackFileSizeThreshold;
} USN_JOURNAL_DATA_V2, *PUSN_JOURNAL_DATA_V2;

#if (NTDDI_VERSION >= NTDDI_WIN8)
typedef USN_JOURNAL_DATA_V1 USN_JOURNAL_DATA, *PUSN_JOURNAL_DATA;
#else /* NTDDI_VERSION < NTDDI_WIN8 */
typedef USN_JOURNAL_DATA_V0 USN_JOURNAL_DATA, *PUSN_JOURNAL_DATA;
#endif /* NTDDI_VERSION < NTDDI_WIN8 */

typedef struct {
    DWORDLONG UsnJournalID;
    DWORD DeleteFlags;
} DELETE_USN_JOURNAL_DATA, *PDELETE_USN_JOURNAL_DATA;

#define USN_DELETE_FLAG_DELETE  (0x00000001)
#define USN_DELETE_FLAG_NOTIFY  (0x00000002)

#define USN_DELETE_VALID_FLAGS  (0x00000003)

typedef struct {

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
    union {
        DWORD UsnSourceInfo;
        DWORD CopyNumber;
    } DUMMYUNIONNAME;
#else /* _WIN32_WINNT < _WIN32_WINNT_WIN8 */
    DWORD UsnSourceInfo;
#endif /*_WIN32_WINNT < _WIN32_WINNT_WIN8 */
    HANDLE VolumeHandle;
    DWORD HandleInfo;
} MARK_HANDLE_INFO, *PMARK_HANDLE_INFO;

#ifdef _WIN64
typedef struct {
#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
    union {
        DWORD UsnSourceInfo;
        DWORD CopyNumber;
    } DUMMYUNIONNAME;
#else /*_WIN32_WINNT < _WIN32_WINNT_WIN8 */
    DWORD UsnSourceInfo;
#endif /*_WIN32_WINNT < _WIN32_WINNT_WIN8 */
    UINT32 VolumeHandle;
    DWORD HandleInfo;
} MARK_HANDLE_INFO32, *PMARK_HANDLE_INFO32;
#endif /* _win64 */

#define USN_SOURCE_DATA_MANAGEMENT  (0x00000001)
#define USN_SOURCE_AUXILIARY_DATA  (0x00000002)
#define USN_SOURCE_REPLICATION_MANAGEMENT  (0x00000004)
#define USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT  (0x00000008)

#define USN_SOURCE_VALID_FLAGS  (USN_SOURCE_DATA_MANAGEMENT |  \
  USN_SOURCE_AUXILIARY_DATA |  \
  USN_SOURCE_REPLICATION_MANAGEMENT |  \
  USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT)

#define MARK_HANDLE_PROTECT_CLUSTERS  (0x00000001)
#define MARK_HANDLE_TXF_SYSTEM_LOG  (0x00000004)
#define MARK_HANDLE_NOT_TXF_SYSTEM_LOG  (0x00000008)

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define MARK_HANDLE_REALTIME  (0x00000020)
#define MARK_HANDLE_NOT_REALTIME  (0x00000040)
#define MARK_HANDLE_FILTER_METADATA  (0x00000200)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
#define MARK_HANDLE_READ_COPY  (0x00000080)
#define MARK_HANDLE_NOT_READ_COPY  (0x00000100)
#define MARK_HANDLE_RETURN_PURGE_FAILURE  (0x00000400)
#endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define MARK_HANDLE_CLOUD_SYNC  (0x00000800)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
#define MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION  (0x00001000)
#define MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO  (0x00002000)
#define MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES (0x00004000)
#endif /*_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define NO_8DOT3_NAME_PRESENT  (0x00000001)
#define REMOVED_8DOT3_NAME  (0x00000002)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */


#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
typedef struct {
    ACCESS_MASK DesiredAccess;
    DWORD SecurityIds[1];
} BULK_SECURITY_TEST_DATA, *PBULK_SECURITY_TEST_DATA;
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)

#define VOLUME_IS_DIRTY  (0x00000001)
#define VOLUME_UPGRADE_SCHEDULED  (0x00000002)
#define VOLUME_SESSION_OPEN  (0x00000004)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)

typedef struct _FILE_PREFETCH {
    DWORD Type;
    DWORD Count;
    DWORDLONG Prefetch[1];
} FILE_PREFETCH, *PFILE_PREFETCH;

typedef struct _FILE_PREFETCH_EX {
    DWORD Type;
    DWORD Count;
    PVOID Context;
    DWORDLONG Prefetch[1];
} FILE_PREFETCH_EX, *PFILE_PREFETCH_EX;

#define FILE_PREFETCH_TYPE_FOR_CREATE  0x1
#define FILE_PREFETCH_TYPE_FOR_DIRENUM  0x2
#define FILE_PREFETCH_TYPE_FOR_CREATE_EX  0x3
#define FILE_PREFETCH_TYPE_FOR_DIRENUM_EX  0x4

#define FILE_PREFETCH_TYPE_MAX  0x4

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

typedef struct _FILESYSTEM_STATISTICS {
    WORD FileSystemType;
    WORD Version;
    DWORD SizeOfCompleteStructure;
    DWORD UserFileReads;
    DWORD UserFileReadBytes;
    DWORD UserDiskReads;
    DWORD UserFileWrites;
    DWORD UserFileWriteBytes;
    DWORD UserDiskWrites;
    DWORD MetaDataReads;
    DWORD MetaDataReadBytes;
    DWORD MetaDataDiskReads;
    DWORD MetaDataWrites;
    DWORD MetaDataWriteBytes;
    DWORD MetaDataDiskWrites;
} FILESYSTEM_STATISTICS, *PFILESYSTEM_STATISTICS;

#define FILESYSTEM_STATISTICS_TYPE_NTFS  1
#define FILESYSTEM_STATISTICS_TYPE_FAT  2
#define FILESYSTEM_STATISTICS_TYPE_EXFAT  3
#define FILESYSTEM_STATISTICS_TYPE_REFS  4

typedef struct _FAT_STATISTICS {
    DWORD CreateHits;
    DWORD SuccessfulCreates;
    DWORD FailedCreates;

    DWORD NonCachedReads;
    DWORD NonCachedReadBytes;
    DWORD NonCachedWrites;
    DWORD NonCachedWriteBytes;

    DWORD NonCachedDiskReads;
    DWORD NonCachedDiskWrites;
} FAT_STATISTICS, *PFAT_STATISTICS;

typedef struct _EXFAT_STATISTICS {
    DWORD CreateHits;
    DWORD SuccessfulCreates;
    DWORD FailedCreates;

    DWORD NonCachedReads;
    DWORD NonCachedReadBytes;
    DWORD NonCachedWrites;
    DWORD NonCachedWriteBytes;

    DWORD NonCachedDiskReads;
    DWORD NonCachedDiskWrites;
} EXFAT_STATISTICS, *PEXFAT_STATISTICS;

typedef struct _NTFS_STATISTICS {
    DWORD LogFileFullExceptions;
    DWORD OtherExceptions;
    DWORD MftReads;
    DWORD MftReadBytes;
    DWORD MftWrites;
    DWORD MftWriteBytes;
    struct {
        WORD Write;
        WORD Create;
        WORD SetInfo;
        WORD Flush;
    } MftWritesUserLevel;
    WORD MftWritesFlushForLogFileFull;
    WORD MftWritesLazyWriter;
    WORD MftWritesUserRequest;
    DWORD Mft2Writes;
    DWORD Mft2WriteBytes;
    struct {
        WORD Write;
        WORD Create;
        WORD SetInfo;
        WORD Flush;
    } Mft2WritesUserLevel;
    WORD Mft2WritesFlushForLogFileFull;
    WORD Mft2WritesLazyWriter;
    WORD Mft2WritesUserRequest;
    DWORD RootIndexReads;
    DWORD RootIndexReadBytes;
    DWORD RootIndexWrites;
    DWORD RootIndexWriteBytes;
    DWORD BitmapReads;
    DWORD BitmapReadBytes;
    DWORD BitmapWrites;
    DWORD BitmapWriteBytes;
    WORD BitmapWritesFlushForLogFileFull;
    WORD BitmapWritesLazyWriter;
    WORD BitmapWritesUserRequest;
    struct {
        WORD Write;
        WORD Create;
        WORD SetInfo;
    } BitmapWritesUserLevel;
    DWORD MftBitmapReads;
    DWORD MftBitmapReadBytes;
    DWORD MftBitmapWrites;
    DWORD MftBitmapWriteBytes;
    WORD MftBitmapWritesFlushForLogFileFull;
    WORD MftBitmapWritesLazyWriter;
    WORD MftBitmapWritesUserRequest;
    struct {
        WORD Write;
        WORD Create;
        WORD SetInfo;
        WORD Flush;
    } MftBitmapWritesUserLevel;
    DWORD UserIndexReads;
    DWORD UserIndexReadBytes;
    DWORD UserIndexWrites;
    DWORD UserIndexWriteBytes;
    DWORD LogFileReads;
    DWORD LogFileReadBytes;
    DWORD LogFileWrites;
    DWORD LogFileWriteBytes;
    struct {
        DWORD Calls;
        DWORD Clusters;
        DWORD Hints;
        DWORD RunsReturned;
        DWORD HintsHonored;
        DWORD HintsClusters;
        DWORD Cache;
        DWORD CacheClusters;
        DWORD CacheMiss;
        DWORD CacheMissClusters;
    } Allocate;
    DWORD DiskResourcesExhausted;
} NTFS_STATISTICS, *PNTFS_STATISTICS;

typedef struct _FILESYSTEM_STATISTICS_EX {
    WORD FileSystemType;
    WORD Version;
    DWORD SizeOfCompleteStructure;
    DWORDLONG UserFileReads;
    DWORDLONG UserFileReadBytes;
    DWORDLONG UserDiskReads;
    DWORDLONG UserFileWrites;
    DWORDLONG UserFileWriteBytes;
    DWORDLONG UserDiskWrites;
    DWORDLONG MetaDataReads;
    DWORDLONG MetaDataReadBytes;
    DWORDLONG MetaDataDiskReads;
    DWORDLONG MetaDataWrites;
    DWORDLONG MetaDataWriteBytes;
    DWORDLONG MetaDataDiskWrites;
} FILESYSTEM_STATISTICS_EX, *PFILESYSTEM_STATISTICS_EX;

typedef struct _NTFS_STATISTICS_EX {
    DWORD LogFileFullExceptions;
    DWORD OtherExceptions;
    DWORDLONG MftReads;
    DWORDLONG MftReadBytes;
    DWORDLONG MftWrites;
    DWORDLONG MftWriteBytes;
    struct {
        DWORD Write;
        DWORD Create;
        DWORD SetInfo;
        DWORD Flush;
    } MftWritesUserLevel;
    DWORD MftWritesFlushForLogFileFull;
    DWORD MftWritesLazyWriter;
    DWORD MftWritesUserRequest;
    DWORDLONG Mft2Writes;
    DWORDLONG Mft2WriteBytes;
    struct {
        DWORD Write;
        DWORD Create;
        DWORD SetInfo;
        DWORD Flush;
    } Mft2WritesUserLevel;
    DWORD Mft2WritesFlushForLogFileFull;
    DWORD Mft2WritesLazyWriter;
    DWORD Mft2WritesUserRequest;
    DWORDLONG RootIndexReads;
    DWORDLONG RootIndexReadBytes;
    DWORDLONG RootIndexWrites;
    DWORDLONG RootIndexWriteBytes;
    DWORDLONG BitmapReads;
    DWORDLONG BitmapReadBytes;
    DWORDLONG BitmapWrites;
    DWORDLONG BitmapWriteBytes;
    DWORD BitmapWritesFlushForLogFileFull;
    DWORD BitmapWritesLazyWriter;
    DWORD BitmapWritesUserRequest;
    struct {
        DWORD Write;
        DWORD Create;
        DWORD SetInfo;
        DWORD Flush;
    } BitmapWritesUserLevel;
    DWORDLONG MftBitmapReads;
    DWORDLONG MftBitmapReadBytes;
    DWORDLONG MftBitmapWrites;
    DWORDLONG MftBitmapWriteBytes;
    DWORD MftBitmapWritesFlushForLogFileFull;
    DWORD MftBitmapWritesLazyWriter;
    DWORD MftBitmapWritesUserRequest;
    struct {
        DWORD Write;
        DWORD Create;
        DWORD SetInfo;
        DWORD Flush;
    } MftBitmapWritesUserLevel;
    DWORDLONG UserIndexReads;
    DWORDLONG UserIndexReadBytes;
    DWORDLONG UserIndexWrites;
    DWORDLONG UserIndexWriteBytes;
    DWORDLONG LogFileReads;
    DWORDLONG LogFileReadBytes;
    DWORDLONG LogFileWrites;
    DWORDLONG LogFileWriteBytes;
    struct {
        DWORD Calls;
        DWORD RunsReturned;
        DWORD Hints;
        DWORD HintsHonored;
        DWORD Cache;
        DWORD CacheMiss;
        DWORDLONG Clusters;
        DWORDLONG HintsClusters;
        DWORDLONG CacheClusters;
        DWORDLONG CacheMissClusters;
    } Allocate;
    DWORD DiskResourcesExhausted;
    DWORDLONG VolumeTrimCount;
    DWORDLONG VolumeTrimTime;
    DWORDLONG VolumeTrimByteCount;
    DWORDLONG FileLevelTrimCount;
    DWORDLONG FileLevelTrimTime;
    DWORDLONG FileLevelTrimByteCount;
    DWORDLONG VolumeTrimSkippedCount;
    DWORDLONG VolumeTrimSkippedByteCount;
} NTFS_STATISTICS_EX, *PNTFS_STATISTICS_EX;

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
typedef struct _FILE_OBJECTID_BUFFER {
    BYTE ObjectId[16];
    union {
        struct {
            BYTE BirthVolumeId[16];
            BYTE BirthObjectId[16];
            BYTE DomainId[16];
        } DUMMYSTRUCTNAME;
        BYTE ExtendedInfo[48];
    } DUMMYUNIONNAME;
} FILE_OBJECTID_BUFFER, *PFILE_OBJECTID_BUFFER;
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
typedef struct _FILE_SET_SPARSE_BUFFER {
    BOOLEAN SetSparse;
} FILE_SET_SPARSE_BUFFER, *PFILE_SET_SPARSE_BUFFER;
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
typedef struct _FILE_ZERO_DATA_INFORMATION {
    LARGE_INTEGER FileOffset;
    LARGE_INTEGER BeyondFinalZero;
} FILE_ZERO_DATA_INFORMATION, *PFILE_ZERO_DATA_INFORMATION;
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)

#define FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA  (0x00000001)

typedef struct _FILE_ZERO_DATA_INFORMATION_EX {
    LARGE_INTEGER FileOffset;
    LARGE_INTEGER BeyondFinalZero;
    DWORD Flags;
} FILE_ZERO_DATA_INFORMATION_EX, *PFILE_ZERO_DATA_INFORMATION_EX;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
typedef struct _FILE_ALLOCATED_RANGE_BUFFER {
    LARGE_INTEGER FileOffset;
    LARGE_INTEGER Length;
} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)

typedef struct _ENCRYPTION_BUFFER {
    DWORD EncryptionOperation;
    BYTE Private[1];
} ENCRYPTION_BUFFER, *PENCRYPTION_BUFFER;

#define FILE_SET_ENCRYPTION  0x00000001
#define FILE_CLEAR_ENCRYPTION  0x00000002
#define STREAM_SET_ENCRYPTION  0x00000003
#define STREAM_CLEAR_ENCRYPTION  0x00000004

#define MAXIMUM_ENCRYPTION_VALUE  0x00000004

typedef struct _DECRYPTION_STATUS_BUFFER {
    BOOLEAN NoEncryptedStreams;
} DECRYPTION_STATUS_BUFFER, *PDECRYPTION_STATUS_BUFFER;

#define ENCRYPTION_FORMAT_DEFAULT  (0x01)

typedef struct _REQUEST_RAW_ENCRYPTED_DATA {
    LONGLONG FileOffset;
    DWORD Length;
} REQUEST_RAW_ENCRYPTED_DATA, *PREQUEST_RAW_ENCRYPTED_DATA;

typedef struct _ENCRYPTED_DATA_INFO {
    DWORDLONG StartingFileOffset;
    DWORD OutputBufferOffset;
    DWORD BytesWithinFileSize;
    DWORD BytesWithinValidDataLength;
    WORD CompressionFormat;
    BYTE DataUnitShift;
    BYTE ChunkShift;
    BYTE ClusterShift;
    BYTE EncryptionFormat;
    WORD NumberOfDataBlocks;
    DWORD DataBlockSize[ANYSIZE_ARRAY];
} ENCRYPTED_DATA_INFO, *PENCRYPTED_DATA_INFO;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

#define ENCRYPTED_DATA_INFO_SPARSE_FILE  1

typedef struct _EXTENDED_ENCRYPTED_DATA_INFO {
    DWORD ExtendedCode;
    DWORD Length;
    DWORD Flags;
    DWORD Reserved;
} EXTENDED_ENCRYPTED_DATA_INFO, *PEXTENDED_ENCRYPTED_DATA_INFO;

#endif /*(_WIN32_WINNT >= _WIN32_WINNT_WIN7)*/

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)
typedef struct _PLEX_READ_DATA_REQUEST {
    LARGE_INTEGER ByteOffset;
    DWORD ByteLength;
    DWORD PlexNumber;
} PLEX_READ_DATA_REQUEST, *PPLEX_READ_DATA_REQUEST;
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN2K)

typedef struct _SI_COPYFILE {
    DWORD SourceFileNameLength;
    DWORD DestinationFileNameLength;
    DWORD Flags;
    WCHAR FileNameBuffer[1];
} SI_COPYFILE, *PSI_COPYFILE;

#define COPYFILE_SIS_LINK  0x0001
#define COPYFILE_SIS_REPLACE  0x0002
#define COPYFILE_SIS_FLAGS  0x0003

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN2K */

#if (_WIN32_WINNT >= _WIN32_WINNT_VISTA)

typedef struct _FILE_MAKE_COMPATIBLE_BUFFER {
    BOOLEAN CloseDisc;
} FILE_MAKE_COMPATIBLE_BUFFER, *PFILE_MAKE_COMPATIBLE_BUFFER;

typedef struct _FILE_SET_DEFECT_MGMT_BUFFER {
    BOOLEAN Disable;
} FILE_SET_DEFECT_MGMT_BUFFER, *PFILE_SET_DEFECT_MGMT_BUFFER;

typedef struct _FILE_QUERY_SPARING_BUFFER {
    DWORD SparingUnitBytes;
    BOOLEAN SoftwareSparing;
    DWORD TotalSpareBlocks;
    DWORD FreeSpareBlocks;
} FILE_QUERY_SPARING_BUFFER, *PFILE_QUERY_SPARING_BUFFER;

typedef struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER {
    LARGE_INTEGER DirectoryCount;
    LARGE_INTEGER FileCount;
    WORD FsFormatMajVersion;
    WORD FsFormatMinVersion;
    WCHAR FsFormatName[12];
    LARGE_INTEGER FormatTime;
    LARGE_INTEGER LastUpdateTime;
    WCHAR CopyrightInfo[34];
    WCHAR AbstractInfo[34];
    WCHAR FormattingImplementationInfo[34];
    WCHAR LastModifyingImplementationInfo[34];
} FILE_QUERY_ON_DISK_VOL_INFO_BUFFER, *PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER;

#define SET_REPAIR_ENABLED  (0x00000001)
#define SET_REPAIR_WARN_ABOUT_DATA_LOSS  (0x00000008)
#define SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT  (0x00000010)
#define SET_REPAIR_VALID_MASK  (0x00000019)

#define FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE  (0x0000000000000001)
#define FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED  (0x0000000000000002)
#define FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST  (0x0000000000000004)
#define FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD  (0x0000000000000008)
#define FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE  (0x0000000000000010)
#define FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED  (0x0000000000000020)
#define FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR  (0x0000000000000040)
#define FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED  (0x0000000000000080)
#define FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED  (0x0000000000000100)
#define FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED  (0x0000000000000200)
#define FILE_INITIATE_REPAIR_HINT1_REPAIRED  (0x0000000000000400)
#define FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG  (0x0000000000000800)
#define FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND  (0x0000000000001000)
#define FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK  (0x0000000000002000)
#define FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION  (0x0000000000004000)
#define FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE  (0x0000000000008000)
#define FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST  (0x0000000000010000)
#define FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH  (0x0000000000020000)
#define FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN  (0x0000000000040000)
#define FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD  (0x0000000000080000)
#define FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT  (0x0000000000100000)
#define FILE_INITIATE_REPAIR_HINT1_SID_VALID  (0x0000000000200000)
#define FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH  (0x0000000000400000)
#define FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT  (0x0000000000800000)
#define FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE  (0x0000000001000000)
#define FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED  (0x0000000002000000)
#define FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST  (0x0000000004000000)
#define FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD  (0x0000000008000000)
#define FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX  (0x0000000010000000)
#define FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY  (0x0000000020000000)
#define FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES  (0x0000000040000000)
#define FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE  (0x0000000080000000)
#define FILE_INITIATE_REPAIR_HINT1_INVALID_LCN  (0x0000000100000000)
#define FILE_INITIATE_REPAIR_HINT1_INVALID_VCN  (0x0000000200000000)
#define FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT  (0x0000000400000000)
#define FILE_INITIATE_REPAIR_HINT1_ORPHAN  (0x0000000800000000)
#define FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL  (0x0000001000000000)
#define FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT  (0x0000002000000000)
#define FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG  (0x0000004000000000)
#define FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID  (0x0000008000000000)
#define FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH  (0x0000010000000000)
#define FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME  (0x0000020000000000)
#define FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES  (0x0000040000000000)

typedef DWORDLONG CLSN;

typedef struct _FILE_INITIATE_REPAIR_OUTPUT_BUFFER {
    DWORDLONG Hint1;
    DWORDLONG Hint2;
    CLSN Clsn;
    DWORD Status;
} FILE_INITIATE_REPAIR_OUTPUT_BUFFER, *PFILE_INITIATE_REPAIR_OUTPUT_BUFFER;

typedef enum _SHRINK_VOLUME_REQUEST_TYPES {
    ShrinkPrepare = 1,
    ShrinkCommit,
    ShrinkAbort
} SHRINK_VOLUME_REQUEST_TYPES, *PSHRINK_VOLUME_REQUEST_TYPES;

typedef struct _SHRINK_VOLUME_INFORMATION {
    SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
    DWORDLONG Flags;
    LONGLONG NewNumberOfSectors;
} SHRINK_VOLUME_INFORMATION, *PSHRINK_VOLUME_INFORMATION;

#define TXFS_RM_FLAG_LOGGING_MODE  0x00000001
#define TXFS_RM_FLAG_RENAME_RM  0x00000002
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX  0x00000004
#define TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN  0x00000008
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS  0x00000010
#define TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT  0x00000020
#define TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE  0x00000040
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX  0x00000080
#define TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN  0x00000100
#define TXFS_RM_FLAG_GROW_LOG  0x00000400
#define TXFS_RM_FLAG_SHRINK_LOG  0x00000800
#define TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE  0x00001000
#define TXFS_RM_FLAG_PRESERVE_CHANGES  0x00002000
#define TXFS_RM_FLAG_RESET_RM_AT_NEXT_START  0x00004000
#define TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START  0x00008000
#define TXFS_RM_FLAG_PREFER_CONSISTENCY  0x00010000
#define TXFS_RM_FLAG_PREFER_AVAILABILITY  0x00020000

#define TXFS_LOGGING_MODE_SIMPLE  (0x0001)
#define TXFS_LOGGING_MODE_FULL  (0x0002)

#define TXFS_TRANSACTION_STATE_NONE  0x00
#define TXFS_TRANSACTION_STATE_ACTIVE  0x01
#define TXFS_TRANSACTION_STATE_PREPARED  0x02
#define TXFS_TRANSACTION_STATE_NOTACTIVE  0x03

#define TXFS_MODIFY_RM_VALID_FLAGS  \
  (TXFS_RM_FLAG_LOGGING_MODE  |  \
  TXFS_RM_FLAG_RENAME_RM  |  \
  TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX  |  \
  TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN  |  \
  TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS  |  \
  TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT  |  \
  TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE  |  \
  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX  |  \
  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN  |  \
  TXFS_RM_FLAG_SHRINK_LOG  |  \
  TXFS_RM_FLAG_GROW_LOG  |  \
  TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE  |  \
  TXFS_RM_FLAG_PRESERVE_CHANGES  |  \
  TXFS_RM_FLAG_RESET_RM_AT_NEXT_START  |  \
  TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START  |  \
  TXFS_RM_FLAG_PREFER_CONSISTENCY  |  \
  TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_MODIFY_RM {
    DWORD Flags;
    DWORD LogContainerCountMax;
    DWORD LogContainerCountMin;
    DWORD LogContainerCount;
    DWORD LogGrowthIncrement;
    DWORD LogAutoShrinkPercentage;
    DWORDLONG Reserved;
    WORD LoggingMode;
} TXFS_MODIFY_RM, *PTXFS_MODIFY_RM;

#define TXFS_RM_STATE_NOT_STARTED  0
#define TXFS_RM_STATE_STARTING  1
#define TXFS_RM_STATE_ACTIVE  2
#define TXFS_RM_STATE_SHUTTING_DOWN  3

#define TXFS_QUERY_RM_INFORMATION_VALID_FLAGS  \
  (TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS  |  \
  TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT  |  \
  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX  |  \
  TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN  |  \
  TXFS_RM_FLAG_RESET_RM_AT_NEXT_START  |  \
  TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START  |  \
  TXFS_RM_FLAG_PREFER_CONSISTENCY  |  \
  TXFS_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_QUERY_RM_INFORMATION {
    DWORD BytesRequired;
    DWORDLONG TailLsn;
    DWORDLONG CurrentLsn;
    DWORDLONG ArchiveTailLsn;
    DWORDLONG LogContainerSize;
    LARGE_INTEGER HighestVirtualClock;
    DWORD LogContainerCount;
    DWORD LogContainerCountMax;
    DWORD LogContainerCountMin;
    DWORD LogGrowthIncrement;
    DWORD LogAutoShrinkPercentage;
    DWORD Flags;
    WORD LoggingMode;
    WORD Reserved;
    DWORD RmState;
    DWORDLONG LogCapacity;
    DWORDLONG LogFree;
    DWORDLONG TopsSize;
    DWORDLONG TopsUsed;
    DWORDLONG TransactionCount;
    DWORDLONG OnePCCount;
    DWORDLONG TwoPCCount;
    DWORDLONG NumberLogFileFull;
    DWORDLONG OldestTransactionAge;
    GUID RMName;
    DWORD TmLogPathOffset;
} TXFS_QUERY_RM_INFORMATION, *PTXFS_QUERY_RM_INFORMATION;

#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN  0x01
#define TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK  0x02

#define TXFS_ROLLFORWARD_REDO_VALID_FLAGS  \
  (TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN |  \
  TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK)

typedef struct _TXFS_ROLLFORWARD_REDO_INFORMATION {
    LARGE_INTEGER LastVirtualClock;
    DWORDLONG LastRedoLsn;
    DWORDLONG HighestRecoveryLsn;
    DWORD Flags;
} TXFS_ROLLFORWARD_REDO_INFORMATION, *PTXFS_ROLLFORWARD_REDO_INFORMATION;

#ifdef DEPRECATE_SUPPORTED
#ifndef USE_TXF_DEPRECATED_FUNCTIONALITY
#pragma deprecated(TXFS_ROLLFORWARD_REDO_INFORMATION)
#pragma deprecated(PTXFS_ROLLFORWARD_REDO_INFORMATION)
#endif
#endif

#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX  0x00000001
#define TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN  0x00000002
#define TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE  0x00000004
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS  0x00000008
#define TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT  0x00000010
#define TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE  0x00000020
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX  0x00000040
#define TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN  0x00000080

#define TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT  0x00000200
#define TXFS_START_RM_FLAG_LOGGING_MODE  0x00000400
#define TXFS_START_RM_FLAG_PRESERVE_CHANGES  0x00000800

#define TXFS_START_RM_FLAG_PREFER_CONSISTENCY  0x00001000
#define TXFS_START_RM_FLAG_PREFER_AVAILABILITY  0x00002000

#define TXFS_START_RM_VALID_FLAGS  \
  (TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX  |  \
  TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN  |  \
  TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE  |  \
  TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS |  \
  TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT  |  \
  TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE  |  \
  TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT  |  \
  TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX  |  \
  TXFS_START_RM_FLAG_LOGGING_MODE  |  \
  TXFS_START_RM_FLAG_PRESERVE_CHANGES  |  \
  TXFS_START_RM_FLAG_PREFER_CONSISTENCY  |  \
  TXFS_START_RM_FLAG_PREFER_AVAILABILITY)

typedef struct _TXFS_START_RM_INFORMATION {
    DWORD Flags;
    DWORDLONG LogContainerSize;
    DWORD LogContainerCountMin;
    DWORD LogContainerCountMax;
    DWORD LogGrowthIncrement;
    DWORD LogAutoShrinkPercentage;
    DWORD TmLogPathOffset;
    WORD TmLogPathLength;
    WORD LoggingMode;
    WORD LogPathLength;
    WORD Reserved;
    WCHAR LogPath[1];
} TXFS_START_RM_INFORMATION, *PTXFS_START_RM_INFORMATION;

#ifdef DEPRECATE_SUPPORTED
#ifndef USE_TXF_DEPRECATED_FUNCTIONALITY
#pragma deprecated(TXFS_START_RM_INFORMATION)
#pragma deprecated(PTXFS_START_RM_INFORMATION)
#endif
#endif

typedef struct _TXFS_GET_METADATA_INFO_OUT {
    struct {
        LONGLONG LowPart;
        LONGLONG HighPart;
    } TxfFileId;
    GUID LockingTransaction;
    DWORDLONG LastLsn;
    DWORD TransactionState;
} TXFS_GET_METADATA_INFO_OUT, *PTXFS_GET_METADATA_INFO_OUT;

#define TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED  0x00000001
#define TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED  0x00000002

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY {
    DWORDLONG Offset;
    DWORD NameFlags;
    LONGLONG FileId;
    DWORD Reserved1;
    DWORD Reserved2;
    LONGLONG Reserved3;
    WCHAR FileName[1];
} TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY, *PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES {
    GUID KtmTransaction;
    DWORDLONG NumberOfFiles;
    DWORDLONG BufferSizeRequired;
    DWORDLONG Offset;
} TXFS_LIST_TRANSACTION_LOCKED_FILES, *PTXFS_LIST_TRANSACTION_LOCKED_FILES;

typedef struct _TXFS_LIST_TRANSACTIONS_ENTRY {
    GUID TransactionId;
    DWORD TransactionState;
    DWORD Reserved1;
    DWORD Reserved2;
    LONGLONG Reserved3;
} TXFS_LIST_TRANSACTIONS_ENTRY, *PTXFS_LIST_TRANSACTIONS_ENTRY;

typedef struct _TXFS_LIST_TRANSACTIONS {
    DWORDLONG NumberOfTransactions;
    DWORDLONG BufferSizeRequired;
} TXFS_LIST_TRANSACTIONS, *PTXFS_LIST_TRANSACTIONS;

typedef struct _TXFS_READ_BACKUP_INFORMATION_OUT {
    union {
        DWORD BufferLength;
        BYTE Buffer[1];
    } DUMMYUNIONNAME;
} TXFS_READ_BACKUP_INFORMATION_OUT, *PTXFS_READ_BACKUP_INFORMATION_OUT;

typedef struct _TXFS_WRITE_BACKUP_INFORMATION {
    BYTE Buffer[1];
} TXFS_WRITE_BACKUP_INFORMATION, *PTXFS_WRITE_BACKUP_INFORMATION;

#define TXFS_TRANSACTED_VERSION_NONTRANSACTED  0xFFFFFFFE
#define TXFS_TRANSACTED_VERSION_UNCOMMITTED  0xFFFFFFFF

typedef struct _TXFS_GET_TRANSACTED_VERSION {
    DWORD ThisBaseVersion;
    DWORD LatestVersion;
    WORD ThisMiniVersion;
    WORD FirstMiniVersion;
    WORD LatestMiniVersion;
} TXFS_GET_TRANSACTED_VERSION, *PTXFS_GET_TRANSACTED_VERSION;

#define TXFS_SAVEPOINT_SET  0x00000001
#define TXFS_SAVEPOINT_ROLLBACK  0x00000002
#define TXFS_SAVEPOINT_CLEAR  0x00000004
#define TXFS_SAVEPOINT_CLEAR_ALL  0x00000010

typedef struct _TXFS_SAVEPOINT_INFORMATION {
    HANDLE KtmTransaction;
    DWORD ActionCode;
    DWORD SavepointId;
} TXFS_SAVEPOINT_INFORMATION, *PTXFS_SAVEPOINT_INFORMATION;

#ifdef DEPRECATE_SUPPORTED
#ifndef USE_TXF_DEPRECATED_FUNCTIONALITY
#pragma deprecated(TXFS_SAVEPOINT_INFORMATION)
#pragma deprecated(PTXFS_SAVEPOINT_INFORMATION)
#endif
#endif

typedef struct _TXFS_CREATE_MINIVERSION_INFO {
    WORD StructureVersion;
    WORD StructureLength;
    DWORD BaseVersion;
    WORD MiniVersion;
} TXFS_CREATE_MINIVERSION_INFO, *PTXFS_CREATE_MINIVERSION_INFO;

#ifdef DEPRECATE_SUPPORTED
#ifndef USE_TXF_DEPRECATED_FUNCTIONALITY
#pragma deprecated(TXFS_CREATE_MINIVERSION_INFO)
#pragma deprecated(PTXFS_CREATE_MINIVERSION_INFO)
#endif
#endif

typedef struct _TXFS_TRANSACTION_ACTIVE_INFO {
    BOOLEAN TransactionsActiveAtSnapshot;
} TXFS_TRANSACTION_ACTIVE_INFO, *PTXFS_TRANSACTION_ACTIVE_INFO;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_VISTA */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

typedef struct _BOOT_AREA_INFO {
    DWORD BootSectorCount;
    struct {
        LARGE_INTEGER Offset;
    } BootSectors[2];
} BOOT_AREA_INFO, *PBOOT_AREA_INFO;

typedef struct _RETRIEVAL_POINTER_BASE {
    LARGE_INTEGER FileAreaOffset;
} RETRIEVAL_POINTER_BASE, *PRETRIEVAL_POINTER_BASE;

typedef struct _FILE_FS_PERSISTENT_VOLUME_INFORMATION {
    DWORD VolumeFlags;
    DWORD FlagMask;
    DWORD Version;
    DWORD Reserved;
} FILE_FS_PERSISTENT_VOLUME_INFORMATION, *PFILE_FS_PERSISTENT_VOLUME_INFORMATION;

#define PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED  (0x00000001)

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)
#define PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED  (0x00000002)
#endif  /* _WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)
#define PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY  (0x00000004)
#define PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY  (0x00000008)
#define PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING  (0x00000010)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINBLUE */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
#define PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM  (0x00000020)
#define PERSISTENT_VOLUME_STATE_BACKED_BY_WIM  (0x00000040)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
#define PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING  (0x00000080)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */

#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
#define PERSISTENT_VOLUME_STATE_TXF_DISABLED  (0x00000100)
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */

typedef struct _FILE_SYSTEM_RECOGNITION_INFORMATION {
    CHAR FileSystem[9];
} FILE_SYSTEM_RECOGNITION_INFORMATION, *PFILE_SYSTEM_RECOGNITION_INFORMATION;

#define OPLOCK_LEVEL_CACHE_READ  (0x00000001)
#define OPLOCK_LEVEL_CACHE_HANDLE  (0x00000002)
#define OPLOCK_LEVEL_CACHE_WRITE  (0x00000004)

#define REQUEST_OPLOCK_INPUT_FLAG_REQUEST  (0x00000001)
#define REQUEST_OPLOCK_INPUT_FLAG_ACK  (0x00000002)
#define REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE (0x00000004)

#define REQUEST_OPLOCK_CURRENT_VERSION  1

typedef struct _REQUEST_OPLOCK_INPUT_BUFFER {
    WORD StructureVersion;
    WORD StructureLength;
    DWORD RequestedOplockLevel;
    DWORD Flags;
} REQUEST_OPLOCK_INPUT_BUFFER, *PREQUEST_OPLOCK_INPUT_BUFFER;

#define REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED  (0x00000001)
#define REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED  (0x00000002)

typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER {
    WORD StructureVersion;
    WORD StructureLength;
    DWORD OriginalOplockLevel;
    DWORD NewOplockLevel;
    DWORD Flags;
    ACCESS_MASK AccessMode;
    WORD ShareMode;
} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;

#ifndef _VIRTUAL_STORAGE_TYPE_DEFINED
#define _VIRTUAL_STORAGE_TYPE_DEFINED
typedef struct _VIRTUAL_STORAGE_TYPE {
    DWORD DeviceId;
    GUID VendorId;
} VIRTUAL_STORAGE_TYPE, *PVIRTUAL_STORAGE_TYPE;
#endif

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST {
    DWORD RequestLevel;
    DWORD RequestFlags;
} STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST, *PSTORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;

#define QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES  0x1
#define QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES  0x2

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY {
    DWORD EntryLength;
    DWORD DependencyTypeFlags;
    DWORD ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
} STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY, *PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY {
    DWORD EntryLength;
    DWORD DependencyTypeFlags;
    DWORD ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    DWORD AncestorLevel;
    DWORD HostVolumeNameOffset;
    DWORD HostVolumeNameSize;
    DWORD DependentVolumeNameOffset;
    DWORD DependentVolumeNameSize;
    DWORD RelativePathOffset;
    DWORD RelativePathSize;
    DWORD DependentDeviceNameOffset;
    DWORD DependentDeviceNameSize;
} STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY, *PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;

#ifdef _MSC_EXTENSIONS
typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE {
  DWORD  ResponseLevel;
  DWORD  NumberEntries;
  union {
  STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY Lev1Depends[];
  STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY Lev2Depends[];
  } DUMMYUNIONNAME;
} STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE, *PSTORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
#endif /* _MSC_EXTENSIONS */

#define SD_GLOBAL_CHANGE_TYPE_MACHINE_SID  1
#define SD_GLOBAL_CHANGE_TYPE_QUERY_STATS  (1 << 16)
#define SD_GLOBAL_CHANGE_TYPE_ENUM_SDS  (2 << 16)

typedef struct _SD_CHANGE_MACHINE_SID_INPUT {
    WORD CurrentMachineSIDOffset;
    WORD CurrentMachineSIDLength;
    WORD NewMachineSIDOffset;
    WORD NewMachineSIDLength;
} SD_CHANGE_MACHINE_SID_INPUT, *PSD_CHANGE_MACHINE_SID_INPUT;

typedef struct _SD_CHANGE_MACHINE_SID_OUTPUT {
    DWORDLONG NumSDChangedSuccess;
    DWORDLONG NumSDChangedFail;
    DWORDLONG NumSDUnused;
    DWORDLONG NumSDTotal;
    DWORDLONG NumMftSDChangedSuccess;
    DWORDLONG NumMftSDChangedFail;
    DWORDLONG NumMftSDTotal;
} SD_CHANGE_MACHINE_SID_OUTPUT, *PSD_CHANGE_MACHINE_SID_OUTPUT;

typedef struct _SD_QUERY_STATS_INPUT {
    DWORD Reserved;
} SD_QUERY_STATS_INPUT, *PSD_QUERY_STATS_INPUT;

typedef struct _SD_QUERY_STATS_OUTPUT {
    DWORDLONG SdsStreamSize;
    DWORDLONG SdsAllocationSize;
    DWORDLONG SiiStreamSize;
    DWORDLONG SiiAllocationSize;
    DWORDLONG SdhStreamSize;
    DWORDLONG SdhAllocationSize;
    DWORDLONG NumSDTotal;
    DWORDLONG NumSDUnused;
} SD_QUERY_STATS_OUTPUT, *PSD_QUERY_STATS_OUTPUT;

typedef struct _SD_ENUM_SDS_INPUT {
    DWORDLONG StartingOffset;
    DWORDLONG MaxSDEntriesToReturn;
} SD_ENUM_SDS_INPUT, *PSD_ENUM_SDS_INPUT;

typedef struct _SD_ENUM_SDS_ENTRY {
    DWORD Hash;
    DWORD SecurityId;
    DWORDLONG Offset;
    DWORD Length;
    BYTE Descriptor[1];
} SD_ENUM_SDS_ENTRY, *PSD_ENUM_SDS_ENTRY;

typedef struct _SD_ENUM_SDS_OUTPUT {
    DWORDLONG NextOffset;
    DWORDLONG NumSDEntriesReturned;
    DWORDLONG NumSDBytesReturned;
    SD_ENUM_SDS_ENTRY SDEntry[1];
} SD_ENUM_SDS_OUTPUT, *PSD_ENUM_SDS_OUTPUT;

typedef struct _SD_GLOBAL_CHANGE_INPUT {
    DWORD Flags;
    DWORD ChangeType;
    union {
        SD_CHANGE_MACHINE_SID_INPUT SdChange;
        SD_QUERY_STATS_INPUT SdQueryStats;
        SD_ENUM_SDS_INPUT SdEnumSds;
    } DUMMYUNIONNAME;
} SD_GLOBAL_CHANGE_INPUT, *PSD_GLOBAL_CHANGE_INPUT;

typedef struct _SD_GLOBAL_CHANGE_OUTPUT {
    DWORD Flags;
    DWORD ChangeType;
    union {

        SD_CHANGE_MACHINE_SID_OUTPUT SdChange;
        SD_QUERY_STATS_OUTPUT SdQueryStats;
        SD_ENUM_SDS_OUTPUT SdEnumSds;
    } DUMMYUNIONNAME;
} SD_GLOBAL_CHANGE_OUTPUT, *PSD_GLOBAL_CHANGE_OUTPUT;

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_INPUT {
    DWORD Flags;
    DWORD NumberOfClusters;
    LARGE_INTEGER Cluster[1];
} LOOKUP_STREAM_FROM_CLUSTER_INPUT, *PLOOKUP_STREAM_FROM_CLUSTER_INPUT;

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT {
    DWORD Offset;
    DWORD NumberOfMatches;
    DWORD BufferSizeRequired;
} LOOKUP_STREAM_FROM_CLUSTER_OUTPUT, *PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT;

#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE  0x00000001
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET  0x00000002
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE  0x00000004
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE  0x00000008

#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK  0xff000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA  0x01000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX  0x02000000
#define LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM  0x03000000

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_ENTRY {
    DWORD OffsetToNext;
    DWORD Flags;
    LARGE_INTEGER Reserved;
    LARGE_INTEGER Cluster;
    WCHAR FileName[1];
} LOOKUP_STREAM_FROM_CLUSTER_ENTRY, *PLOOKUP_STREAM_FROM_CLUSTER_ENTRY;

typedef struct _FILE_TYPE_NOTIFICATION_INPUT {
    DWORD Flags;
    DWORD NumFileTypeIDs;
    GUID FileTypeID[1];
} FILE_TYPE_NOTIFICATION_INPUT, *PFILE_TYPE_NOTIFICATION_INPUT;

#define FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN  0x00000001
#define FILE_TYPE_NOTIFICATION_FLAG_USAGE_END  0x00000002

DEFINE_GUID(FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE, 0x0d0a64a1, 0x38fc, 0x4db8, 0x9f, 0xe7, 0x3f, 0x43, 0x52, 0xcd, 0x7c, 0x5c);
DEFINE_GUID(FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE, 0xb7624d64, 0xb9a3, 0x4cf8, 0x80, 0x11, 0x5b, 0x86, 0xc9, 0x40, 0xe7, 0xb7);
DEFINE_GUID(FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE, 0x9d453eb7, 0xd2a6, 0x4dbd, 0xa2, 0xe3, 0xfb, 0xd0, 0xed, 0x91, 0x09, 0xa9);

#define CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED 0x00000001

typedef struct _CSV_MGMT_LOCK {
    DWORD Flags;
} CSV_MGMT_LOCK, *PCSV_MGMT_LOCK;

typedef struct _CSV_NAMESPACE_INFO {
    DWORD Version;
    DWORD DeviceNumber;
    LARGE_INTEGER StartingOffset;
    DWORD SectorSize;
} CSV_NAMESPACE_INFO, *PCSV_NAMESPACE_INFO;

#define CSV_NAMESPACE_INFO_V1 (sizeof(CSV_NAMESPACE_INFO))
#define CSV_INVALID_DEVICE_NUMBER 0xFFFFFFFF

typedef enum _CSV_CONTROL_OP {
    CsvControlStartRedirectFile = 0x02,
    CsvControlStopRedirectFile = 0x03,
    CsvControlQueryRedirectState = 0x04,
    CsvControlQueryFileRevision = 0x06,
    CsvControlQueryMdsPath = 0x08,
    CsvControlQueryFileRevisionFileId128 = 0x09,
    CsvControlQueryVolumeRedirectState = 0x0a,
    CsvControlEnableUSNRangeModificationTracking = 0x0d,
    CsvControlMarkHandleLocalVolumeMount = 0x0e,
    CsvControlUnmarkHandleLocalVolumeMount = 0x0f,
} CSV_CONTROL_OP, *PCSV_CONTROL_OP;

typedef struct _CSV_CONTROL_PARAM {
    CSV_CONTROL_OP Operation;
    LONGLONG Unused;
} CSV_CONTROL_PARAM, *PCSV_CONTROL_PARAM;

typedef struct _CSV_QUERY_REDIRECT_STATE {
    DWORD MdsNodeId;
    DWORD DsNodeId;
    BOOLEAN FileRedirected;
} CSV_QUERY_REDIRECT_STATE, *PCSV_QUERY_REDIRECT_STATE;

typedef struct _CSV_QUERY_FILE_REVISION {
    LONGLONG FileId;
    LONGLONG FileRevision[3];

} CSV_QUERY_FILE_REVISION, *PCSV_QUERY_FILE_REVISION;

typedef struct _CSV_QUERY_FILE_REVISION_FILE_ID_128 {
    FILE_ID_128 FileId;
    LONGLONG FileRevision[3];
} CSV_QUERY_FILE_REVISION_FILE_ID_128, *PCSV_QUERY_FILE_REVISION_FILE_ID_128;

typedef struct _CSV_QUERY_MDS_PATH {
    DWORD MdsNodeId;
    DWORD DsNodeId;
    DWORD PathLength;
    WCHAR Path[1];
} CSV_QUERY_MDS_PATH, *PCSV_QUERY_MDS_PATH;

typedef enum _CSVFS_DISK_CONNECTIVITY {
    CsvFsDiskConnectivityNone = 0,
    CsvFsDiskConnectivityMdsNodeOnly = 1,
    CsvFsDiskConnectivitySubsetOfNodes = 2,
    CsvFsDiskConnectivityAllNodes = 3
} CSVFS_DISK_CONNECTIVITY, *PCSVFS_DISK_CONNECTIVITY;

typedef struct _CSV_QUERY_VOLUME_REDIRECT_STATE {
    DWORD MdsNodeId;
    DWORD DsNodeId;
    BOOLEAN IsDiskConnected;
    BOOLEAN ClusterEnableDirectIo;
    CSVFS_DISK_CONNECTIVITY DiskConnectivity;
} CSV_QUERY_VOLUME_REDIRECT_STATE, *PCSV_QUERY_VOLUME_REDIRECT_STATE;

typedef struct _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT {
    DWORDLONG VetoedFromAltitudeIntegral;
    DWORDLONG VetoedFromAltitudeDecimal;
    WCHAR Reason[256];
} CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT, *PCSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

typedef struct _CSV_IS_OWNED_BY_CSVFS {
    BOOLEAN OwnedByCSVFS;
} CSV_IS_OWNED_BY_CSVFS, *PCSV_IS_OWNED_BY_CSVFS;

typedef struct _FILE_LEVEL_TRIM_RANGE {
    DWORDLONG Offset;
    DWORDLONG Length;
} FILE_LEVEL_TRIM_RANGE, *PFILE_LEVEL_TRIM_RANGE;

typedef struct _FILE_LEVEL_TRIM {
    DWORD Key;
    DWORD NumRanges;
    FILE_LEVEL_TRIM_RANGE Ranges[1];
} FILE_LEVEL_TRIM, *PFILE_LEVEL_TRIM;

typedef struct _FILE_LEVEL_TRIM_OUTPUT {
    DWORD NumRangesProcessed;
} FILE_LEVEL_TRIM_OUTPUT, *PFILE_LEVEL_TRIM_OUTPUT;

#define QUERY_FILE_LAYOUT_RESTART  (0x00000001)
#define QUERY_FILE_LAYOUT_INCLUDE_NAMES  (0x00000002)
#define QUERY_FILE_LAYOUT_INCLUDE_STREAMS  (0x00000004)
#define QUERY_FILE_LAYOUT_INCLUDE_EXTENTS  (0x00000008)
#define QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO  (0x00000010)

#define QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED  (0x00000020)

typedef enum _QUERY_FILE_LAYOUT_FILTER_TYPE {
    QUERY_FILE_LAYOUT_FILTER_TYPE_NONE = 0,
    QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS = 1,
    QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID = 2,
    QUERY_FILE_LAYOUT_NUM_FILTER_TYPES = 3,
} QUERY_FILE_LAYOUT_FILTER_TYPE;

typedef struct _CLUSTER_RANGE {
    LARGE_INTEGER StartingCluster;
    LARGE_INTEGER ClusterCount;
} CLUSTER_RANGE, *PCLUSTER_RANGE;

typedef struct _FILE_REFERENCE_RANGE {
    DWORDLONG StartingFileReferenceNumber;
    DWORDLONG EndingFileReferenceNumber;
} FILE_REFERENCE_RANGE, *PFILE_REFERENCE_RANGE;

typedef struct _QUERY_FILE_LAYOUT_INPUT {
    DWORD NumberOfPairs;
    DWORD Flags;
    QUERY_FILE_LAYOUT_FILTER_TYPE FilterType;
    DWORD Reserved;
    union {
        CLUSTER_RANGE ClusterRanges[1];
        FILE_REFERENCE_RANGE FileReferenceRanges[1];

    } Filter;
} QUERY_FILE_LAYOUT_INPUT, *PQUERY_FILE_LAYOUT_INPUT;

#define QUERY_FILE_LAYOUT_SINGLE_INSTANCED  (0x00000001)

typedef struct _QUERY_FILE_LAYOUT_OUTPUT {
    DWORD FileEntryCount;
    DWORD FirstFileOffset;
    DWORD Flags;
    DWORD Reserved;
} QUERY_FILE_LAYOUT_OUTPUT, *PQUERY_FILE_LAYOUT_OUTPUT;

typedef struct _FILE_LAYOUT_ENTRY {
    DWORD Version;
    DWORD NextFileOffset;
    DWORD Flags;
    DWORD FileAttributes;
    DWORDLONG FileReferenceNumber;
    DWORD FirstNameOffset;
    DWORD FirstStreamOffset;
    DWORD ExtraInfoOffset;
    DWORD Reserved;
} FILE_LAYOUT_ENTRY, *PFILE_LAYOUT_ENTRY;

#define FILE_LAYOUT_NAME_ENTRY_PRIMARY  (0x00000001)
#define FILE_LAYOUT_NAME_ENTRY_DOS  (0x00000002)

typedef struct _FILE_LAYOUT_NAME_ENTRY {
    DWORD NextNameOffset;
    DWORD Flags;
    DWORDLONG ParentFileReferenceNumber;
    DWORD FileNameLength;
    DWORD Reserved;
    WCHAR FileName[1];
} FILE_LAYOUT_NAME_ENTRY, *PFILE_LAYOUT_NAME_ENTRY;

typedef struct _FILE_LAYOUT_INFO_ENTRY {
    struct {
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        DWORD FileAttributes;
    } BasicInformation;
    DWORD OwnerId;
    DWORD SecurityId;
    USN Usn;
} FILE_LAYOUT_INFO_ENTRY, *PFILE_LAYOUT_INFO_ENTRY;

#define STREAM_LAYOUT_ENTRY_IMMOVABLE  (0x00000001)
#define STREAM_LAYOUT_ENTRY_PINNED  (0x00000002)
#define STREAM_LAYOUT_ENTRY_RESIDENT  (0x00000004)
#define STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED  (0x00000008)

typedef struct _STREAM_LAYOUT_ENTRY {
    DWORD Version;
    DWORD NextStreamOffset;
    DWORD Flags;
    DWORD ExtentInformationOffset;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORDLONG Reserved;
    DWORD AttributeFlags;
    DWORD StreamIdentifierLength;
    WCHAR StreamIdentifier[1];
} STREAM_LAYOUT_ENTRY, *PSTREAM_LAYOUT_ENTRY;

#define STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS  (0x00000001)
#define STREAM_EXTENT_ENTRY_ALL_EXTENTS  (0x00000002)

typedef struct _STREAM_EXTENT_ENTRY {
    DWORD Flags;
    union {
        RETRIEVAL_POINTERS_BUFFER RetrievalPointers;
    } ExtentInformation;
} STREAM_EXTENT_ENTRY, *PSTREAM_EXTENT_ENTRY;

#define CHECKSUM_TYPE_UNCHANGED  (-1)

#define CHECKSUM_TYPE_NONE  (0)
#define CHECKSUM_TYPE_CRC32  (1)
#define CHECKSUM_TYPE_CRC64  (2)
#define CHECKSUM_TYPE_ECC  (3)
#define CHECKSUM_TYPE_FIRST_UNUSED_TYPE (4)

#define FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF  (1)

typedef struct _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER {
    WORD ChecksumAlgorithm;
    WORD Reserved;
    DWORD Flags;
    DWORD ChecksumChunkSizeInBytes;
    DWORD ClusterSizeInBytes;
} FSCTL_GET_INTEGRITY_INFORMATION_BUFFER, *PFSCTL_GET_INTEGRITY_INFORMATION_BUFFER;

typedef struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER {
    WORD ChecksumAlgorithm;
    WORD Reserved;
    DWORD Flags;
} FSCTL_SET_INTEGRITY_INFORMATION_BUFFER, *PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER;

#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)
typedef struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX {
    BYTE EnableIntegrity;
    BYTE KeepIntegrityStateUnchanged;
    WORD Reserved;
    DWORD Flags;
    BYTE Version;
    BYTE Reserved2[7];
} FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX, *PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */

typedef struct _FSCTL_OFFLOAD_READ_INPUT {
    DWORD Size;
    DWORD Flags;
    DWORD TokenTimeToLive;
    DWORD Reserved;
    DWORDLONG FileOffset;
    DWORDLONG CopyLength;
} FSCTL_OFFLOAD_READ_INPUT, *PFSCTL_OFFLOAD_READ_INPUT;

typedef struct _FSCTL_OFFLOAD_READ_OUTPUT {
    DWORD Size;
    DWORD Flags;
    DWORDLONG TransferLength;
    BYTE Token[512];
} FSCTL_OFFLOAD_READ_OUTPUT, *PFSCTL_OFFLOAD_READ_OUTPUT;

#define OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE  (1)

typedef struct _FSCTL_OFFLOAD_WRITE_INPUT {
    DWORD Size;
    DWORD Flags;
    DWORDLONG FileOffset;
    DWORDLONG CopyLength;
    DWORDLONG TransferOffset;
    BYTE Token[512];
} FSCTL_OFFLOAD_WRITE_INPUT, *PFSCTL_OFFLOAD_WRITE_INPUT;

typedef struct _FSCTL_OFFLOAD_WRITE_OUTPUT {
    DWORD Size;
    DWORD Flags;
    DWORDLONG LengthWritten;
} FSCTL_OFFLOAD_WRITE_OUTPUT, *PFSCTL_OFFLOAD_WRITE_OUTPUT;

typedef struct _SET_PURGE_FAILURE_MODE_INPUT {
    DWORD Flags;
} SET_PURGE_FAILURE_MODE_INPUT, *PSET_PURGE_FAILURE_MODE_INPUT;

#define SET_PURGE_FAILURE_MODE_ENABLED  0x00000001
#define SET_PURGE_FAILURE_MODE_DISABLED  0x00000002

typedef struct _DEDUP_QUERY_FILE_HASHES_INPUT_BUFFER {
    DWORD Version;
    DWORD QueryFlags;
    DWORD HashAlgorithm;
    LARGE_INTEGER RangeOffsetInFile;
    LARGE_INTEGER RangeLength;
} DEDUP_QUERY_FILE_HASHES_INPUT_BUFFER, *PDEDUP_QUERY_FILE_HASHES_INPUT_BUFFER;

typedef struct _DEDUP_CHUNK_INFORMATION_HASH32 {
    DWORD ChunkFlags;
    LONGLONG ChunkOffsetInFile;
    LONGLONG ChunkSize;
    BYTE HashVal[32];
} DEDUP_CHUNK_INFORMATION_HASH32, *PDEDUP_CHUNK_INFORMATION_HASH32;

typedef struct _DEDUP_FILE_OPERATION {
    DWORD Code;
} DEDUP_FILE_OPERATION, *PDEDUP_FILE_OPERATION;

#define DEDUP_FILE_OP_NOTIFY_OPTIMIZATION  0xc0000013
#define DEDUP_FILE_OP_SET_ZERO_DATA  0xc0000002
#define DEDUP_FILE_RECALL  0xc0000009
#define DEDUP_FILE_OP_SET_REPARSE_POINT 0xc0000001

typedef struct _REPAIR_COPIES_INPUT {
    DWORD Size;
    DWORD Flags;
    LARGE_INTEGER FileOffset;
    DWORD Length;
    DWORD SourceCopy;
    DWORD NumberOfRepairCopies;
    DWORD RepairCopies[ANYSIZE_ARRAY];
} REPAIR_COPIES_INPUT, *PREPAIR_COPIES_INPUT;

typedef struct _REPAIR_COPIES_OUTPUT {
    DWORD Size;
    DWORD Status;
    LARGE_INTEGER ResumeFileOffset;
} REPAIR_COPIES_OUTPUT, *PREPAIR_COPIES_OUTPUT;

#define FILE_REGION_USAGE_VALID_CACHED_DATA  0x00000001
#define FILE_REGION_USAGE_VALID_NONCACHED_DATA  0x00000002

typedef struct _FILE_REGION_INFO {
    LONGLONG FileOffset;
    LONGLONG Length;
    DWORD Usage;
    DWORD Reserved;
} FILE_REGION_INFO, *PFILE_REGION_INFO;

typedef struct _FILE_REGION_OUTPUT {
    DWORD Flags;
    DWORD TotalRegionEntryCount;
    DWORD RegionEntryCount;
    DWORD Reserved;
    FILE_REGION_INFO Region[1];
} FILE_REGION_OUTPUT, *PFILE_REGION_OUTPUT;

typedef struct _FILE_REGION_INPUT {
    LONGLONG FileOffset;
    LONGLONG Length;
    DWORD DesiredUsage;
} FILE_REGION_INPUT, *PFILE_REGION_INPUT;

#endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN8)

#define VALID_WRITE_USN_REASON_MASK  (USN_REASON_DATA_OVERWRITE | USN_REASON_CLOSE)

typedef struct _WRITE_USN_REASON_INPUT {
    DWORD Flags;
    DWORD UsnReasonToWrite;
} WRITE_USN_REASON_INPUT, *PWRITE_USN_REASON_INPUT;

#endif /*_WIN32_WINNT >= _WIN32_WINNT_WIN8 */

#if (_WIN32_WINNT >= _WIN32_WINNT_WINBLUE)

#define FILE_STORAGE_TIER_NAME_LENGTH  (256)
#define FILE_STORAGE_TIER_DESCRIPTION_LENGTH  (512)

#define FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY  (0x00020000)
#define FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE  (0x00200000)
#define FILE_STORAGE_TIER_FLAG_READ_CACHE  (0x00400000)
#define FILE_STORAGE_TIER_FLAG_PARITY  (0x00800000)

typedef enum _FILE_STORAGE_TIER_MEDIA_TYPE {
    FileStorageTierMediaTypeUnspecified = 0,
    FileStorageTierMediaTypeDisk,
    FileStorageTierMediaTypeSsd
} FILE_STORAGE_TIER_MEDIA_TYPE, *PFILE_STORAGE_TIER_MEDIA_TYPE;

typedef struct _FILE_STORAGE_TIER {
    GUID Id;
    WCHAR Name[FILE_STORAGE_TIER_NAME_LENGTH];
    WCHAR Description[FILE_STORAGE_TIER_NAME_LENGTH];
    DWORDLONG Flags;
    DWORDLONG ProvisionedCapacity;
    FILE_STORAGE_TIER_MEDIA_TYPE MediaType;
} FILE_STORAGE_TIER, *PFILE_STORAGE_TIER;

#define QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE  0x80000000
#define QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ  0x40000000
#define QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME  0x20000000

typedef struct _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    DWORD TotalNumberOfTiers;
    DWORD NumberOfTiersReturned;
    FILE_STORAGE_TIER Tiers[ANYSIZE_ARRAY];
} FSCTL_QUERY_STORAGE_CLASSES_OUTPUT, *PFSCTL_QUERY_STORAGE_CLASSES_OUTPUT;

#define FSCTL_QUERY_STORAGE_CLASSES_OUTPUT_VERSION  sizeof(FSCTL_QUERY_STORAGE_CLASSES_OUTPUT)

typedef struct _FSCTL_QUERY_REGION_INFO_INPUT {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    DWORD NumberOfTierIds;
    GUID TierIds[ANYSIZE_ARRAY];
} FSCTL_QUERY_REGION_INFO_INPUT, *PFSCTL_QUERY_REGION_INFO_INPUT;

#define FSCTL_QUERY_REGION_INFO_INPUT_VERSION  sizeof(FSCTL_QUERY_REGION_INFO_INPUT)

typedef struct _FILE_STORAGE_TIER_REGION {
    GUID TierId;
    DWORDLONG Offset;
    DWORDLONG Length;
} FILE_STORAGE_TIER_REGION, *PFILE_STORAGE_TIER_REGION;

typedef struct _FSCTL_QUERY_REGION_INFO_OUTPUT {
    DWORD Version;
    DWORD Size;
    DWORD Flags;
    DWORD Reserved;
    DWORDLONG Alignment;
    DWORD TotalNumberOfRegions;
    DWORD NumberOfRegionsReturned;
    FILE_STORAGE_TIER_REGION Regions[ANYSIZE_ARRAY];
} FSCTL_QUERY_REGION_INFO_OUTPUT, *PFSCTL_QUERY_REGION_INFO_OUTPUT;

#define FSCTL_QUERY_REGION_INFO_OUTPUT_VERSION  sizeof(FSCTL_QUERY_REGION_INFO_OUTPUT)

typedef struct _DUPLICATE_EXTENTS_DATA {
    HANDLE FileHandle;
    LARGE_INTEGER SourceFileOffset;
    LARGE_INTEGER TargetFileOffset;
    LARGE_INTEGER ByteCount;
} DUPLICATE_EXTENTS_DATA, *PDUPLICATE_EXTENTS_DATA;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINBLUE */

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)

#define WOF_CURRENT_VERSION (0x00000001)

#define WOF_PROVIDER_WIM  (0x00000001)
#define WOF_PROVIDER_FILE  (0x00000002)
#define WOF_PROVIDER_CLOUD  (0x00000003)

typedef struct _WOF_EXTERNAL_INFO {
    DWORD Version;
    DWORD Provider;
} WOF_EXTERNAL_INFO, *PWOF_EXTERNAL_INFO;

typedef struct _WOF_EXTERNAL_FILE_ID {
    FILE_ID_128 FileId;
} WOF_EXTERNAL_FILE_ID, *PWOF_EXTERNAL_FILE_ID;

typedef struct _WOF_VERSION_INFO {
    DWORD WofVersion;
} WOF_VERSION_INFO, *PWOF_VERSION_INFO;

#ifndef WIM_PROVIDER_HASH_SIZE
#define WIM_PROVIDER_HASH_SIZE 20
#endif

#define WIM_PROVIDER_CURRENT_VERSION  (0x00000001)

#define WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE  (0x00000001)
#define WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED  (0x00000002)

typedef struct _WIM_PROVIDER_EXTERNAL_INFO {
    DWORD Version;
    DWORD Flags;
    LARGE_INTEGER DataSourceId;
    BYTE ResourceHash[WIM_PROVIDER_HASH_SIZE];
} WIM_PROVIDER_EXTERNAL_INFO, *PWIM_PROVIDER_EXTERNAL_INFO;

#define WIM_BOOT_OS_WIM  (0x00000001)
#define WIM_BOOT_NOT_OS_WIM  (0x00000000)

typedef struct _WIM_PROVIDER_ADD_OVERLAY_INPUT {
    DWORD WimType;
    DWORD WimIndex;
    DWORD WimFileNameOffset;
    DWORD WimFileNameLength;
} WIM_PROVIDER_ADD_OVERLAY_INPUT, *PWIM_PROVIDER_ADD_OVERLAY_INPUT;

typedef struct _WIM_PROVIDER_UPDATE_OVERLAY_INPUT {
    LARGE_INTEGER DataSourceId;
    DWORD WimFileNameOffset;
    DWORD WimFileNameLength;
} WIM_PROVIDER_UPDATE_OVERLAY_INPUT, *PWIM_PROVIDER_UPDATE_OVERLAY_INPUT;

typedef struct _WIM_PROVIDER_REMOVE_OVERLAY_INPUT {
    LARGE_INTEGER DataSourceId;
} WIM_PROVIDER_REMOVE_OVERLAY_INPUT, *PWIM_PROVIDER_REMOVE_OVERLAY_INPUT;

typedef struct _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT {
    LARGE_INTEGER DataSourceId;
} WIM_PROVIDER_SUSPEND_OVERLAY_INPUT, *PWIM_PROVIDER_SUSPEND_OVERLAY_INPUT;

typedef struct _WIM_PROVIDER_OVERLAY_ENTRY {
    DWORD NextEntryOffset;
    LARGE_INTEGER DataSourceId;
    GUID WimGuid;
    DWORD WimFileNameOffset;
    DWORD WimType;
    DWORD WimIndex;
    DWORD Flags;
} WIM_PROVIDER_OVERLAY_ENTRY, *PWIM_PROVIDER_OVERLAY_ENTRY;

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

#define FILE_PROVIDER_CURRENT_VERSION  (0x00000001)

#define FILE_PROVIDER_SINGLE_FILE  (0x00000001)

#define FILE_PROVIDER_COMPRESSION_XPRESS4K  (0x00000000)
#define FILE_PROVIDER_COMPRESSION_LZX  (0x00000001)
#define FILE_PROVIDER_COMPRESSION_XPRESS8K  (0x00000002)
#define FILE_PROVIDER_COMPRESSION_XPRESS16K  (0x00000003)
#define FILE_PROVIDER_COMPRESSION_MAXIMUM  (0x00000004)

#define FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE (0x00000001)

typedef struct _FILE_PROVIDER_EXTERNAL_INFO_V0 {
    DWORD Version;
    DWORD Algorithm;
} FILE_PROVIDER_EXTERNAL_INFO_V0, *PFILE_PROVIDER_EXTERNAL_INFO_V0;

typedef struct _FILE_PROVIDER_EXTERNAL_INFO_V1 {
    DWORD Version;
    DWORD Algorithm;
    DWORD Flags;
} FILE_PROVIDER_EXTERNAL_INFO_V1, *PFILE_PROVIDER_EXTERNAL_INFO_V1;

typedef FILE_PROVIDER_EXTERNAL_INFO_V1 FILE_PROVIDER_EXTERNAL_INFO;
typedef PFILE_PROVIDER_EXTERNAL_INFO_V1 PFILE_PROVIDER_EXTERNAL_INFO;

#if (_WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD)

typedef struct _CONTAINER_VOLUME_STATE {
    DWORD Flags;
} CONTAINER_VOLUME_STATE, *PCONTAINER_VOLUME_STATE;

#define CONTAINER_VOLUME_STATE_HOSTING_CONTAINER  (0x00000001)

typedef struct _CONTAINER_ROOT_INFO_INPUT {
    DWORD Flags;
} CONTAINER_ROOT_INFO_INPUT, *PCONTAINER_ROOT_INFO_INPUT;

typedef struct _CONTAINER_ROOT_INFO_OUTPUT {
    WORD ContainerRootIdLength;
    BYTE ContainerRootId[ANYSIZE_ARRAY];
} CONTAINER_ROOT_INFO_OUTPUT, *PCONTAINER_ROOT_INFO_OUTPUT;

typedef struct _VIRTUALIZATION_INSTANCE_INFO_INPUT {
    DWORD Flags;
} VIRTUALIZATION_INSTANCE_INFO_INPUT, *PVIRTUALIZATION_INSTANCE_INFO_INPUT;

typedef struct _VIRTUALIZATION_INSTANCE_INFO_OUTPUT {
    GUID VirtualizationInstanceID;
} VIRTUALIZATION_INSTANCE_INFO_OUTPUT, *PVIRTUALIZATION_INSTANCE_INFO_OUTPUT;

#define CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT  (0x00000001)
#define CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT  (0x00000002)
#define CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT  (0x00000004)
#define CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT  (0x00000008)
#define CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT  (0x00000010)

#define CONTAINER_ROOT_INFO_VALID_FLAGS  (0x0000001f)

#endif /* _WIN32_WINNT >= _WIN32_WINNT_WINTHRESHOLD */

#endif /* _FILESYSTEMFSCTL_ */

#ifndef SMB_CCF_APP_INSTANCE_EA_NAME
#define SMB_CCF_APP_INSTANCE_EA_NAME  "ClusteredApplicationInstance"
#endif /* SMB_CCF_APP_INSTANCE_EA_NAME */

#ifndef _NETWORK_APP_INSTANCE_EA_DEFINED
#define _NETWORK_APP_INSTANCE_EA_DEFINED

#if (NTDDI_VERSION >= NTDDI_WIN10)

#ifndef NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR
#define NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR 0x00000001
#endif /* NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR */

typedef struct _NETWORK_APP_INSTANCE_EA {
    GUID AppInstanceID;
    DWORD CsvFlags;
} NETWORK_APP_INSTANCE_EA, *PNETWORK_APP_INSTANCE_EA;

#endif /* NTDDI_VERSION >= NTDDI_WIN10 */

#endif /* _NETWORK_APP_INSTANCE_EA_DEFINED */

#define IOCTL_VOLUME_BASE  0x00000056

#if (NTDDI_VERSION >= NTDDI_WIN2K)

#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS  CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _DISK_EXTENT {
    DWORD DiskNumber;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER ExtentLength;
} DISK_EXTENT, *PDISK_EXTENT;

typedef struct _VOLUME_DISK_EXTENTS {
    DWORD NumberOfDiskExtents;
    DISK_EXTENT Extents[ANYSIZE_ARRAY];
} VOLUME_DISK_EXTENTS, *PVOLUME_DISK_EXTENTS;

#define IOCTL_VOLUME_ONLINE  CTL_CODE(IOCTL_VOLUME_BASE, 2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLUME_OFFLINE  CTL_CODE(IOCTL_VOLUME_BASE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#endif  /* NTDDI_VERSION >= NTDDI_WIN2K */

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define IOCTL_VOLUME_IS_CLUSTERED  CTL_CODE(IOCTL_VOLUME_BASE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLUME_GET_GPT_ATTRIBUTES  CTL_CODE(IOCTL_VOLUME_BASE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION {
    DWORDLONG GptAttributes;
} VOLUME_GET_GPT_ATTRIBUTES_INFORMATION, *PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION;

#endif /* NTDDI_VERSION >= NTDDI_WINXP */

#if (NTDDI_VERSION >= NTDDI_WINTHRESHOLD)

#ifndef _IO_IRP_EXT_TRACK_OFFSET_HEADER_
#define _IO_IRP_EXT_TRACK_OFFSET_HEADER_

struct _IO_IRP_EXT_TRACK_OFFSET_HEADER;

typedef VOID (*PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK)(struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *, struct _IO_IRP_EXT_TRACK_OFFSET_HEADER *, LONGLONG);

#define IRP_EXT_TRACK_OFFSET_HEADER_VALIDATION_VALUE 'TO'

typedef struct _IO_IRP_EXT_TRACK_OFFSET_HEADER {
    WORD Validation;
    WORD Flags;
    PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK TrackedOffsetCallback;
} IO_IRP_EXT_TRACK_OFFSET_HEADER, *PIO_IRP_EXT_TRACK_OFFSET_HEADER;

#define EFS_TRACKED_OFFSET_HEADER_FLAG  0x0001
#define SPACES_TRACKED_OFFSET_HEADER_FLAG  0x0002

#endif /* _IO_IRP_EXT_TRACK_OFFSET_HEADER_ */

#endif /* NTDDI_VERSION >= NTDDI_WINTHRESHOLD */

#if __POCC__ >= 290
#pragma warn(pop)
#endif

#endif /* _WINIOCTL_H */
