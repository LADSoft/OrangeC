#ifndef _SYNCHAPI_H
#define _SYNCHAPI_H

#ifdef __ORANGEC__ 
#pragma GCC system_header
#endif

/* ApiSet api-ms-win-core-synch-l1 */

/* #include <apiset.h> */
#include <apisetcconv.h>
#include <minwindef.h>
#include <minwinbase.h>

#define SRWLOCK_INIT  RTL_SRWLOCK_INIT

typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI VOID WINAPI InitializeSRWLock(PSRWLOCK);
WINBASEAPI VOID WINAPI ReleaseSRWLockExclusive(PSRWLOCK);
WINBASEAPI VOID WINAPI ReleaseSRWLockShared(PSRWLOCK);
WINBASEAPI VOID WINAPI AcquireSRWLockExclusive(PSRWLOCK);
WINBASEAPI VOID WINAPI AcquireSRWLockShared(PSRWLOCK);
WINBASEAPI BOOLEAN WINAPI TryAcquireSRWLockExclusive(PSRWLOCK);
WINBASEAPI BOOLEAN WINAPI TryAcquireSRWLockShared(PSRWLOCK);
#endif /* _WIN32_WINNT >= 0x0600 */
WINBASEAPI VOID WINAPI InitializeCriticalSection(LPCRITICAL_SECTION);
WINBASEAPI VOID WINAPI EnterCriticalSection(LPCRITICAL_SECTION);
WINBASEAPI VOID WINAPI LeaveCriticalSection(LPCRITICAL_SECTION);
WINBASEAPI BOOL WINAPI InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION, DWORD);
#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI BOOL WINAPI InitializeCriticalSectionEx(LPCRITICAL_SECTION, DWORD, DWORD);
#endif /* _WIN32_WINNT >= 0x0600 */
WINBASEAPI DWORD WINAPI SetCriticalSectionSpinCount(LPCRITICAL_SECTION, DWORD);
#if (_WIN32_WINNT >= 0x0400)
WINBASEAPI BOOL WINAPI TryEnterCriticalSection(LPCRITICAL_SECTION);
#endif /* _WIN32_WINNT >= 0x0400 */
WINBASEAPI VOID WINAPI DeleteCriticalSection(LPCRITICAL_SECTION);

typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;

#define INIT_ONCE_STATIC_INIT  RTL_RUN_ONCE_INIT
#define INIT_ONCE_CHECK_ONLY  RTL_RUN_ONCE_CHECK_ONLY
#define INIT_ONCE_ASYNC  RTL_RUN_ONCE_ASYNC
#define INIT_ONCE_INIT_FAILED  RTL_RUN_ONCE_INIT_FAILED
#define INIT_ONCE_CTX_RESERVED_BITS  RTL_RUN_ONCE_CTX_RESERVED_BITS

typedef BOOL (WINAPI *PINIT_ONCE_FN)(PINIT_ONCE IniOnce, PVOID, PVOID *);

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI VOID WINAPI InitOnceInitialize(PINIT_ONCE);
WINBASEAPI BOOL WINAPI InitOnceExecuteOnce(PINIT_ONCE, PINIT_ONCE_FN, PVOID, LPVOID *);
WINBASEAPI BOOL WINAPI InitOnceBeginInitialize(LPINIT_ONCE, DWORD, PBOOL, LPVOID *);
WINBASEAPI BOOL WINAPI InitOnceComplete(LPINIT_ONCE, DWORD, LPVOID);
#endif /* _WIN32_WINNT >= 0x0600 */

typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;

#define CONDITION_VARIABLE_INIT  RTL_CONDITION_VARIABLE_INIT
#define CONDITION_VARIABLE_LOCKMODE_SHARED  RTL_CONDITION_VARIABLE_LOCKMODE_SHARED

#if (_WIN32_WINNT >= 0x0600)
WINBASEAPI VOID WINAPI InitializeConditionVariable(PCONDITION_VARIABLE);
WINBASEAPI VOID WINAPI WakeConditionVariable(PCONDITION_VARIABLE);
WINBASEAPI VOID WINAPI WakeAllConditionVariable(PCONDITION_VARIABLE);
WINBASEAPI BOOL WINAPI SleepConditionVariableCS(PCONDITION_VARIABLE, PCRITICAL_SECTION, DWORD);
WINBASEAPI BOOL WINAPI SleepConditionVariableSRW(PCONDITION_VARIABLE, PSRWLOCK, DWORD, ULONG);
#endif /* _WIN32_WINNT >= 0x0600 */

WINBASEAPI BOOL WINAPI SetEvent(HANDLE);
WINBASEAPI BOOL WINAPI ResetEvent(HANDLE);
WINBASEAPI BOOL WINAPI ReleaseSemaphore(HANDLE, LONG, LPLONG);
WINBASEAPI BOOL WINAPI ReleaseMutex(HANDLE);
WINBASEAPI DWORD WINAPI WaitForSingleObject(HANDLE, DWORD);
WINBASEAPI DWORD WINAPI SleepEx(DWORD, BOOL);
WINBASEAPI DWORD WINAPI WaitForSingleObjectEx(HANDLE, DWORD, BOOL);
WINBASEAPI DWORD WINAPI WaitForMultipleObjectsEx(DWORD, CONST HANDLE *, BOOL, DWORD, BOOL);

#define MUTEX_MODIFY_STATE  MUTANT_QUERY_STATE
#define MUTEX_ALL_ACCESS  MUTANT_ALL_ACCESS

WINBASEAPI HANDLE WINAPI CreateMutexA(LPSECURITY_ATTRIBUTES, BOOL, LPCSTR);
WINBASEAPI HANDLE WINAPI CreateMutexW(LPSECURITY_ATTRIBUTES, BOOL, LPCWSTR);
WINBASEAPI HANDLE WINAPI OpenMutexW(DWORD, BOOL, LPCWSTR);
WINBASEAPI HANDLE WINAPI CreateEventA(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCSTR);
WINBASEAPI HANDLE WINAPI CreateEventW(LPSECURITY_ATTRIBUTES, BOOL, BOOL, LPCWSTR);
WINBASEAPI HANDLE WINAPI OpenEventA(DWORD, BOOL, LPCSTR);
WINBASEAPI HANDLE WINAPI OpenEventW(DWORD, BOOL, LPCWSTR);
WINBASEAPI HANDLE WINAPI OpenSemaphoreW(DWORD, BOOL, LPCWSTR);

#ifdef UNICODE
#define CreateMutex  CreateMutexW
#define OpenMutex  OpenMutexW
#define CreateEvent  CreateEventW
#define OpenEvent  OpenEventW
#define OpenSemaphore  OpenSemaphoreW
#else /* !UNICODE */
#define CreateMutex  CreateMutexA
#define CreateEvent  CreateEventA
#define OpenEvent  OpenEventA
#endif /* !UNICODE */

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

typedef VOID (APIENTRY *PTIMERAPCROUTINE)(LPVOID, DWORD, DWORD);

WINBASEAPI HANDLE WINAPI OpenWaitableTimerW(DWORD, BOOL, LPCWSTR);

#ifdef UNICODE
#define OpenWaitableTimer  OpenWaitableTimerW
#endif

#if (_WIN32_WINNT >= _WIN32_WINNT_WIN7)
BOOL WINAPI SetWaitableTimerEx(HANDLE, const LARGE_INTEGER *, LONG, PTIMERAPCROUTINE, LPVOID, PREASON_CONTEXT, ULONG);
#endif /* _WIN32_WINNT >= _WIN32_WINNT_WIN7 */

WINBASEAPI BOOL WINAPI SetWaitableTimer(HANDLE, const LARGE_INTEGER *, LONG, PTIMERAPCROUTINE, LPVOID, BOOL);
WINBASEAPI BOOL WINAPI CancelWaitableTimer(HANDLE);

#if (_WIN32_WINNT >= 0x0600)

#define CREATE_MUTEX_INITIAL_OWNER  0x00000001

#define CREATE_EVENT_MANUAL_RESET  0x00000001
#define CREATE_EVENT_INITIAL_SET  0x00000002

WINBASEAPI HANDLE WINAPI CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
WINBASEAPI HANDLE WINAPI CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);
WINBASEAPI HANDLE WINAPI CreateEventExA(LPSECURITY_ATTRIBUTES, LPCSTR, DWORD, DWORD);
WINBASEAPI HANDLE WINAPI CreateEventExW(LPSECURITY_ATTRIBUTES, LPCWSTR, DWORD, DWORD);
WINBASEAPI HANDLE WINAPI CreateSemaphoreExW(LPSECURITY_ATTRIBUTES, LONG, LONG, LPCWSTR, DWORD, DWORD);
WINBASEAPI HANDLE WINAPI CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES, LPCWSTR, DWORD, DWORD);

#ifdef UNICODE
#define CreateMutexEx  CreateMutexExW
#define CreateEventEx  CreateEventExW
#define CreateSemaphoreEx  CreateSemaphoreExW
#define CreateWaitableTimerEx  CreateWaitableTimerExW
#else /* !UNICODE */
#define CreateMutexEx  CreateMutexExA
#define CreateEventEx  CreateEventExA
#endif /* !UNICODE */

#define CREATE_WAITABLE_TIMER_MANUAL_RESET  0x00000001

#endif /* _WIN32_WINNT >= 0x0600 */

#endif /* (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400) */

typedef RTL_BARRIER SYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER;

#define SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY  0x01
#define SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY 0x02
#define SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE  0x04

BOOL WINAPI EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER, DWORD);
BOOL WINAPI InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER, LONG, LONG);
BOOL WINAPI DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER);
WINBASEAPI VOID WINAPI Sleep(DWORD);
BOOL WINAPI WaitOnAddress(volatile VOID *, PVOID, SIZE_T, DWORD);
VOID WINAPI WakeByAddressSingle(PVOID);
VOID WINAPI WakeByAddressAll(PVOID);

WINBASEAPI DWORD WINAPI SignalObjectAndWait(HANDLE, HANDLE, DWORD, BOOL);
WINBASEAPI DWORD WINAPI WaitForMultipleObjects(DWORD, CONST HANDLE *, BOOL, DWORD);
WINBASEAPI HANDLE WINAPI CreateSemaphoreW(LPSECURITY_ATTRIBUTES, LONG, LONG, LPCWSTR);
WINBASEAPI HANDLE WINAPI CreateWaitableTimerW(LPSECURITY_ATTRIBUTES, BOOL, LPCWSTR);

#ifdef UNICODE
#define CreateSemaphore  CreateSemaphoreW
#define CreateWaitableTimer  CreateWaitableTimerW
#endif /* UNICODE */

#endif /* _SYNCHAPI_H */
