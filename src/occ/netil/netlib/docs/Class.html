<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>DotNetPELib - Class</title>
  </head>
  <body>
    <div align="center"><font size="+3">Class<br>
      </font>
      <div align="left">The Class object holds the declaration for a
        .Net class.&nbsp;&nbsp; A class can be an Enumeration, in fact
        the <a href="Enum.html">Enum</a> object derives from
        Class.&nbsp;&nbsp; The Class object derives from the <a
          href="DataContainer.html">DataContainer</a> object, which
        allows it to hold <a href="Method.html">Method</a> objects, <a
          href="Field.html">Field</a> objects, and other Class or Enum
        objects.&nbsp;&nbsp; Additionally, a class object may hold <a
          href="Property.html">Property</a> objects.&nbsp;&nbsp; Note
        that classes may NOT contain namespaces or assemblies.<br>
        <br>
        The constructor may be called either directly or through the <a
          href="Allocator.html">Allocator</a> object.&nbsp;&nbsp; It
        takes a name, qualifiers such as whether the class is static or
        a value type, a packing value, and the size of the
        object.&nbsp;&nbsp; If the pack value and size of the object are
        both set to -1, these attributes will not be generated for the
        class.<br>
        <br>
        <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Class(std::string
          Name, Qualifiers Flags, int Pack, int Size);</b><b><br>
          <br>
        </b>The pack value and size value may be independently set for
        the class.&nbsp;&nbsp; Note that if either is set to a
        non-negative value, the PE file will have an entry which sets
        both anyway.<br>
        <b><br>
        </b><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void pack(int
          pk) { pack_ = pk; }</b><b><br>
        </b><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void size(int
          sz) { size_ = sz; }<br>
          <br>
        </b>Classes always extend other classes in .Net.&nbsp;&nbsp; If
        an extendsFrom class is not selected, the library will choose
        one of the classes System.ValueType, System.Enum, or
        System.Object based on whether the class is an enumeration and
        the <a href="Qualifier.html">Qualifier</a> flags.<br>
        <br>
        <b></b><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void
          Extends(Class *extendsFrom) { extendsFrom_ = extendsFrom; }<br>
          <br>
        </b>One can add or view class properties.&nbsp; Methods and
        Fields are managed through the underlying DataContainer object.<br>
        <b></b><b><br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Add(Property
          *property);</b><b><br>
        </b><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; const
          std::vector&lt;Property *&gt;&amp; Properties() const { return
          properties_;&nbsp; }</b><b><br>
          <br>
        </b>To set the fact that a class reference is to be an external reference
        for purpose of the object file, use<br>
        <b></b><b><br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bool External() const;
          </b><b><br></b>
        <b></b><b>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void External(bool external);
          </b><b><br></b><br>
	It is possible to traverse the members of a
        class.&nbsp;&nbsp; Normally though, one would start the
        traversal process by calling the related <a href="PELib.html">PELib</a>
        traverse function, which would traverse every object known to the
        library.<br>
        <br>
        <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual bool
          Traverse(Callback &amp;callback) const override;</b><b><br>
        </b><br>
      </div>
    </div>
  </body>
</html>
